
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Term</title>
<meta name="description" content="Documentation of Coq module Term" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Term</h1>
<div class="coq">
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">List</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Arith</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Freevar</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Misc</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Psatz</span>.<br/>
<br/>
<div class="doc">Terms </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">term</span> :=<br/>
| <span class="id">bvar</span> : <span class="id">nat</span> -&gt; <span class="id">term</span><br/>
| <span class="id">fvar</span> : <span class="id">freevar</span> -&gt; <span class="id">term</span><br/>
| <span class="id">lam</span> : <span class="id">term</span> -&gt; <span class="id">term</span><br/>
| <span class="id">app</span> : <span class="id">term</span> -&gt; <span class="id">term</span> -&gt; <span class="id">term</span><br/>
| <span class="id">constr</span> : <span class="id">nat</span> -&gt; <span class="id">list</span> <span class="id">term</span> -&gt; <span class="id">term</span><br/>
| <span class="id">switch</span> : <span class="id">term</span> -&gt; <span class="id">list</span> (<span class="id">nat</span> * <span class="id">term</span>) -&gt; <span class="id">term</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">term_ind2</span> (<span class="id">P</span> : <span class="id">term</span> -&gt; <span class="kwd">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Hbvar</span> : <span class="kwd">forall</span> <span class="id">n</span>, <span class="id">P</span> (<span class="id">bvar</span> <span class="id">n</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Hfvar</span> : <span class="kwd">forall</span> <span class="id">f</span>, <span class="id">P</span> (<span class="id">fvar</span> <span class="id">f</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Hlam</span> : <span class="kwd">forall</span> <span class="id">t</span>, <span class="id">P</span> <span class="id">t</span> -&gt; <span class="id">P</span> (<span class="id">lam</span> <span class="id">t</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Happ</span> : <span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span>, <span class="id">P</span> <span class="id">t1</span> -&gt; <span class="id">P</span> <span class="id">t2</span> -&gt; <span class="id">P</span> (<span class="id">app</span> <span class="id">t1</span> <span class="id">t2</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Hconstr</span> : <span class="kwd">forall</span> <span class="id">p</span> <span class="id">l</span>, <span class="id">Forall</span> <span class="id">P</span> <span class="id">l</span> -&gt; <span class="id">P</span> (<span class="id">constr</span> <span class="id">p</span> <span class="id">l</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Hswitch</span> : <span class="kwd">forall</span> <span class="id">t</span> <span class="id">m</span>, <span class="id">P</span> <span class="id">t</span> -&gt; <span class="id">Forall</span> (<span class="kwd">fun</span> '(<span class="id">p</span>, <span class="id">t2</span>) =&gt; <span class="id">P</span> <span class="id">t2</span>) <span class="id">m</span> -&gt; <span class="id">P</span> (<span class="id">switch</span> <span class="id">t</span> <span class="id">m</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">t</span> : <span class="id">term</span>) : <span class="id">P</span> <span class="id">t</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">t</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">bvar</span> <span class="id">n</span> =&gt; <span class="id">Hbvar</span> <span class="id">n</span><br/>
&nbsp;&nbsp;| <span class="id">fvar</span> <span class="id">f</span> =&gt; <span class="id">Hfvar</span> <span class="id">f</span><br/>
&nbsp;&nbsp;| <span class="id">lam</span> <span class="id">t</span> =&gt; <span class="id">Hlam</span> <span class="id">t</span> (<span class="id">term_ind2</span> <span class="id">P</span> <span class="id">Hbvar</span> <span class="id">Hfvar</span> <span class="id">Hlam</span> <span class="id">Happ</span> <span class="id">Hconstr</span> <span class="id">Hswitch</span> <span class="id">t</span>)<br/>
&nbsp;&nbsp;| <span class="id">app</span> <span class="id">t1</span> <span class="id">t2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Happ</span> <span class="id">t1</span> <span class="id">t2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">term_ind2</span> <span class="id">P</span> <span class="id">Hbvar</span> <span class="id">Hfvar</span> <span class="id">Hlam</span> <span class="id">Happ</span> <span class="id">Hconstr</span> <span class="id">Hswitch</span> <span class="id">t1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">term_ind2</span> <span class="id">P</span> <span class="id">Hbvar</span> <span class="id">Hfvar</span> <span class="id">Hlam</span> <span class="id">Happ</span> <span class="id">Hconstr</span> <span class="id">Hswitch</span> <span class="id">t2</span>)<br/>
&nbsp;&nbsp;| <span class="id">constr</span> <span class="id">p</span> <span class="id">l</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Hconstr</span> <span class="id">p</span> <span class="id">l</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="kwd">fix</span> <span class="id">H</span> (<span class="id">l</span> : <span class="id">_</span>) : <span class="id">Forall</span> <span class="id">P</span> <span class="id">l</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">l</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">nil</span> =&gt; @<span class="id">Forall_nil</span> <span class="id">_</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">cons</span> <span class="id">t</span> <span class="id">l</span> =&gt; @<span class="id">Forall_cons</span> <span class="id">_</span> <span class="id">_</span> <span class="id">t</span> <span class="id">l</span> (<span class="id">term_ind2</span> <span class="id">P</span> <span class="id">Hbvar</span> <span class="id">Hfvar</span> <span class="id">Hlam</span> <span class="id">Happ</span> <span class="id">Hconstr</span> <span class="id">Hswitch</span> <span class="id">t</span>) (<span class="id">H</span> <span class="id">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>) <span class="id">l</span>)<br/>
&nbsp;&nbsp;| <span class="id">switch</span> <span class="id">t</span> <span class="id">m</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Hswitch</span> <span class="id">t</span> <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">term_ind2</span> <span class="id">P</span> <span class="id">Hbvar</span> <span class="id">Hfvar</span> <span class="id">Hlam</span> <span class="id">Happ</span> <span class="id">Hconstr</span> <span class="id">Hswitch</span> <span class="id">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="kwd">fix</span> <span class="id">H</span> (<span class="id">m</span> : <span class="id">_</span>) : <span class="id">Forall</span> (<span class="kwd">fun</span> '(<span class="id">p</span>, <span class="id">t2</span>) =&gt; <span class="id">P</span> <span class="id">t2</span>) <span class="id">m</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">m</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">nil</span> =&gt; @<span class="id">Forall_nil</span> <span class="id">_</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">cons</span> (<span class="id">p</span>, <span class="id">t2</span>) <span class="id">m</span> =&gt; @<span class="id">Forall_cons</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">p</span>, <span class="id">t2</span>) <span class="id">m</span> (<span class="id">term_ind2</span> <span class="id">P</span> <span class="id">Hbvar</span> <span class="id">Hfvar</span> <span class="id">Hlam</span> <span class="id">Happ</span> <span class="id">Hconstr</span> <span class="id">Hswitch</span> <span class="id">t2</span>) (<span class="id">H</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>) <span class="id">m</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">substb</span> <span class="id">k</span> <span class="id">u</span> <span class="id">t</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">t</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">bvar</span> <span class="id">i</span> =&gt; <span class="kwd">if</span> <span class="id">Nat.eq_dec</span> <span class="id">i</span> <span class="id">k</span> <span class="kwd">then</span> <span class="id">u</span> <span class="kwd">else</span> <span class="id">bvar</span> <span class="id">i</span><br/>
&nbsp;&nbsp;| <span class="id">fvar</span> <span class="id">x</span> =&gt; <span class="id">fvar</span> <span class="id">x</span><br/>
&nbsp;&nbsp;| <span class="id">lam</span> <span class="id">t</span> =&gt; <span class="id">lam</span> (<span class="id">substb</span> (<span class="id">S</span> <span class="id">k</span>) <span class="id">u</span> <span class="id">t</span>)<br/>
&nbsp;&nbsp;| <span class="id">app</span> <span class="id">t1</span> <span class="id">t2</span> =&gt; <span class="id">app</span> (<span class="id">substb</span> <span class="id">k</span> <span class="id">u</span> <span class="id">t1</span>) (<span class="id">substb</span> <span class="id">k</span> <span class="id">u</span> <span class="id">t2</span>)<br/>
&nbsp;&nbsp;| <span class="id">constr</span> <span class="id">p</span> <span class="id">l</span> =&gt; <span class="id">constr</span> <span class="id">p</span> (<span class="id">map</span> (<span class="id">substb</span> <span class="id">k</span> <span class="id">u</span>) <span class="id">l</span>)<br/>
&nbsp;&nbsp;| <span class="id">switch</span> <span class="id">t</span> <span class="id">m</span> =&gt; <span class="id">switch</span> (<span class="id">substb</span> <span class="id">k</span> <span class="id">u</span> <span class="id">t</span>) (<span class="id">map</span> (<span class="kwd">fun</span> '(<span class="id">p</span>, <span class="id">t2</span>) =&gt; (<span class="id">p</span>, <span class="id">substb</span> (<span class="id">p</span> + <span class="id">k</span>) <span class="id">u</span> <span class="id">t2</span>)) <span class="id">m</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">t</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">bvar</span> <span class="id">i</span> =&gt; <span class="id">bvar</span> <span class="id">i</span><br/>
&nbsp;&nbsp;| <span class="id">fvar</span> <span class="id">y</span> =&gt; <span class="kwd">if</span> <span class="id">freevar_eq_dec</span> <span class="id">x</span> <span class="id">y</span> <span class="kwd">then</span> <span class="id">bvar</span> <span class="id">k</span> <span class="kwd">else</span> <span class="id">fvar</span> <span class="id">y</span><br/>
&nbsp;&nbsp;| <span class="id">lam</span> <span class="id">t</span> =&gt; <span class="id">lam</span> (<span class="id">closeb</span> (<span class="id">S</span> <span class="id">k</span>) <span class="id">x</span> <span class="id">t</span>)<br/>
&nbsp;&nbsp;| <span class="id">app</span> <span class="id">t1</span> <span class="id">t2</span> =&gt; <span class="id">app</span> (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t1</span>) (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t2</span>)<br/>
&nbsp;&nbsp;| <span class="id">constr</span> <span class="id">p</span> <span class="id">l</span> =&gt; <span class="id">constr</span> <span class="id">p</span> (<span class="id">map</span> (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span>) <span class="id">l</span>)<br/>
&nbsp;&nbsp;| <span class="id">switch</span> <span class="id">t</span> <span class="id">m</span> =&gt; <span class="id">switch</span> (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span>) (<span class="id">map</span> (<span class="kwd">fun</span> '(<span class="id">p</span>, <span class="id">t2</span>) =&gt; (<span class="id">p</span>, <span class="id">closeb</span> (<span class="id">p</span> + <span class="id">k</span>) <span class="id">x</span> <span class="id">t2</span>)) <span class="id">m</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Notation</span> "<span class="id">t</span> [ <span class="id">k</span> &lt;- <span class="id">u</span> ]" := (<span class="id">substb</span> <span class="id">k</span> <span class="id">u</span> <span class="id">t</span>) (<span class="kwd">at</span> <span class="id">level</span> 67).<br/>
<span class="kwd">Notation</span> "<span class="id">t</span> ^^ <span class="id">u</span>" := (<span class="id">t</span> [ 0 &lt;- <span class="id">u</span> ]) (<span class="kwd">at</span> <span class="id">level</span> 67).<br/>
<span class="kwd">Notation</span> "<span class="id">t</span> ^ <span class="id">x</span>" := (<span class="id">t</span> ^^ (<span class="id">fvar</span> <span class="id">x</span>)).<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">substf</span> <span class="id">x</span> <span class="id">u</span> <span class="id">t</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">t</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">bvar</span> <span class="id">i</span> =&gt; <span class="id">bvar</span> <span class="id">i</span><br/>
&nbsp;&nbsp;| <span class="id">fvar</span> <span class="id">y</span> =&gt; <span class="kwd">if</span> <span class="id">freevar_eq_dec</span> <span class="id">x</span> <span class="id">y</span> <span class="kwd">then</span> <span class="id">u</span> <span class="kwd">else</span> <span class="id">fvar</span> <span class="id">y</span><br/>
&nbsp;&nbsp;| <span class="id">lam</span> <span class="id">t</span> =&gt; <span class="id">lam</span> (<span class="id">substf</span> <span class="id">x</span> <span class="id">u</span> <span class="id">t</span>)<br/>
&nbsp;&nbsp;| <span class="id">app</span> <span class="id">t1</span> <span class="id">t2</span> =&gt; <span class="id">app</span> (<span class="id">substf</span> <span class="id">x</span> <span class="id">u</span> <span class="id">t1</span>) (<span class="id">substf</span> <span class="id">x</span> <span class="id">u</span> <span class="id">t2</span>)<br/>
&nbsp;&nbsp;| <span class="id">constr</span> <span class="id">p</span> <span class="id">l</span> =&gt; <span class="id">constr</span> <span class="id">p</span> (<span class="id">map</span> (<span class="id">substf</span> <span class="id">x</span> <span class="id">u</span>) <span class="id">l</span>)<br/>
&nbsp;&nbsp;| <span class="id">switch</span> <span class="id">t</span> <span class="id">m</span> =&gt; <span class="id">switch</span> (<span class="id">substf</span> <span class="id">x</span> <span class="id">u</span> <span class="id">t</span>) (<span class="id">map</span> (<span class="kwd">fun</span> '(<span class="id">p</span>, <span class="id">t2</span>) =&gt; (<span class="id">p</span>, <span class="id">substf</span> <span class="id">x</span> <span class="id">u</span> <span class="id">t2</span>)) <span class="id">m</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Notation</span> "<span class="id">t</span> [ <span class="id">x</span> := <span class="id">u</span> ]" := (<span class="id">substf</span> <span class="id">x</span> <span class="id">u</span> <span class="id">t</span>) (<span class="kwd">at</span> <span class="id">level</span> 67).<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">fv</span> <span class="id">t</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">t</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">bvar</span> <span class="id">i</span> =&gt; <span class="id">nil</span><br/>
&nbsp;&nbsp;| <span class="id">fvar</span> <span class="id">x</span> =&gt; <span class="id">x</span> :: <span class="id">nil</span><br/>
&nbsp;&nbsp;| <span class="id">lam</span> <span class="id">t</span> =&gt; <span class="id">fv</span> <span class="id">t</span><br/>
&nbsp;&nbsp;| <span class="id">app</span> <span class="id">t1</span> <span class="id">t2</span> =&gt; <span class="id">fv</span> <span class="id">t1</span> ++ <span class="id">fv</span> <span class="id">t2</span><br/>
&nbsp;&nbsp;| <span class="id">constr</span> <span class="id">p</span> <span class="id">l</span> =&gt; <span class="id">concat</span> (<span class="id">map</span> <span class="id">fv</span> <span class="id">l</span>)<br/>
&nbsp;&nbsp;| <span class="id">switch</span> <span class="id">t</span> <span class="id">m</span> =&gt; <span class="id">fv</span> <span class="id">t</span> ++ <span class="id">concat</span> (<span class="id">map</span> (<span class="kwd">fun</span> '(<span class="id">p</span>, <span class="id">t2</span>) =&gt; <span class="id">fv</span> <span class="id">t2</span>) <span class="id">m</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">substf_fv</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span> <span class="id">x</span>, <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">t</span> -&gt; <span class="id">t</span> [ <span class="id">x</span> := <span class="id">u</span> ] = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>; <span class="id">intros</span> <span class="id">u</span> <span class="id">x</span> <span class="id">Hx</span>; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;- <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">intuition</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">f_equal</span>; <span class="id">apply</span> <span class="id">IHt</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">f_equal</span>; [<span class="id">apply</span> <span class="id">IHt1</span> | <span class="id">apply</span> <span class="id">IHt2</span>]; <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">Hx</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">f_equal</span>. <span class="id">erewrite</span> <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>. <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">apply</span> <span class="id">H</span>; [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">concat_In</span> <span class="kwd">in</span> <span class="id">Hx</span>. <span class="id">intros</span> <span class="id">Hx2</span>; <span class="id">apply</span> <span class="id">Hx</span>. <span class="id">eexists</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">split</span>; [<span class="id">eassumption</span>|]. <span class="id">apply</span> <span class="id">in_map</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f_equal</span>; [<span class="id">apply</span> <span class="id">IHt</span>; <span class="id">tauto</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|]. <span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>. <span class="id">simpl</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">concat_In</span> <span class="kwd">in</span> <span class="id">Hx</span>. <span class="id">intros</span> <span class="id">Hx2</span>; <span class="id">apply</span> <span class="id">Hx</span>; <span class="id">right</span>; <span class="id">eexists</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">split</span>; [<span class="id">eassumption</span>|]. <span class="id">rewrite</span> <span class="id">in_map_iff</span>; <span class="id">eexists</span>; <span class="id">split</span>; [|<span class="id">eassumption</span>]; <span class="id">reflexivity</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">substb_list</span> <span class="id">k</span> <span class="id">l</span> <span class="id">t</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">l</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">t</span><br/>
&nbsp;&nbsp;| <span class="id">u</span> :: <span class="id">l</span> =&gt; <span class="id">substb</span> <span class="id">k</span> <span class="id">u</span> (<span class="id">substb_list</span> (<span class="id">S</span> <span class="id">k</span>) <span class="id">l</span> <span class="id">t</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">closeb_list</span> <span class="id">k</span> <span class="id">l</span> <span class="id">t</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">l</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">t</span><br/>
&nbsp;&nbsp;| <span class="id">x</span> :: <span class="id">l</span> =&gt; <span class="id">closeb_list</span> (<span class="id">S</span> <span class="id">k</span>) <span class="id">l</span> (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">lc</span> : <span class="id">term</span> -&gt; <span class="kwd">Prop</span> :=<br/>
| <span class="id">lc_var</span> : <span class="kwd">forall</span> <span class="id">v</span>, <span class="id">lc</span> (<span class="id">fvar</span> <span class="id">v</span>)<br/>
| <span class="id">lc_app</span> : <span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span>, <span class="id">lc</span> <span class="id">t1</span> -&gt; <span class="id">lc</span> <span class="id">t2</span> -&gt; <span class="id">lc</span> (<span class="id">app</span> <span class="id">t1</span> <span class="id">t2</span>)<br/>
| <span class="id">lc_lam</span> : <span class="kwd">forall</span> <span class="id">t</span> <span class="id">L</span>, (<span class="kwd">forall</span> <span class="id">x</span>, ~ <span class="id">In</span> <span class="id">x</span> <span class="id">L</span> -&gt; <span class="id">lc</span> (<span class="id">t</span> ^ <span class="id">x</span>)) -&gt; <span class="id">lc</span> (<span class="id">lam</span> <span class="id">t</span>)<br/>
| <span class="id">lc_constr</span> : <span class="kwd">forall</span> <span class="id">p</span> <span class="id">l</span>, (<span class="kwd">forall</span> <span class="id">t</span>, <span class="id">In</span> <span class="id">t</span> <span class="id">l</span> -&gt; <span class="id">lc</span> <span class="id">t</span>) -&gt; <span class="id">lc</span> (<span class="id">constr</span> <span class="id">p</span> <span class="id">l</span>)<br/>
| <span class="id">lc_switch</span> : <span class="kwd">forall</span> <span class="id">t</span> <span class="id">m</span> <span class="id">L</span>, <span class="id">lc</span> <span class="id">t</span> -&gt; (<span class="kwd">forall</span> <span class="id">p</span> <span class="id">t2</span> <span class="id">l</span>, <span class="id">In</span> (<span class="id">p</span>, <span class="id">t2</span>) <span class="id">m</span> -&gt; <span class="id">distinct</span> <span class="id">L</span> <span class="id">p</span> <span class="id">l</span> -&gt; <span class="id">lc</span> (<span class="id">substb_list</span> 0 (<span class="id">map</span> <span class="id">fvar</span> <span class="id">l</span>) <span class="id">t2</span>)) -&gt; <span class="id">lc</span> (<span class="id">switch</span> <span class="id">t</span> <span class="id">m</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">body</span> <span class="id">t</span> := <span class="kwd">exists</span> <span class="id">L</span>, <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">x</span> \<span class="id">notin</span> <span class="id">L</span> -&gt; <span class="id">lc</span> (<span class="id">t</span> ^ <span class="id">x</span>).<br/>
<span class="kwd">Definition</span> <span class="id">bodies</span> <span class="id">n</span> <span class="id">t</span> := <span class="kwd">exists</span> <span class="id">L</span>, <span class="kwd">forall</span> <span class="id">l</span>, <span class="id">distinct</span> <span class="id">L</span> <span class="id">n</span> <span class="id">l</span> -&gt; <span class="id">lc</span> (<span class="id">substb_list</span> 0 (<span class="id">map</span> <span class="id">fvar</span> <span class="id">l</span>) <span class="id">t</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">lc_lam_body</span> : <span class="kwd">forall</span> <span class="id">t</span>, <span class="id">lc</span> (<span class="id">lam</span> <span class="id">t</span>) &lt;-&gt; <span class="id">body</span> <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span>. <span class="id">split</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">H</span>; <span class="id">inversion</span> <span class="id">H</span>; <span class="kwd">exists</span> <span class="id">L</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> [<span class="id">L</span> <span class="id">H</span>]; <span class="id">econstructor</span>; <span class="id">eauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">Forall_ex_mono_exchange</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">A</span> <span class="id">B</span> : <span class="kwd">Type</span>) (<span class="id">P</span> : <span class="id">A</span> -&gt; <span class="id">list</span> <span class="id">B</span> -&gt; <span class="kwd">Prop</span>) (<span class="id">Hmono</span> : <span class="kwd">forall</span> <span class="id">x</span> <span class="id">L1</span> <span class="id">L2</span>, <span class="id">L1</span> \<span class="id">subseteq</span> <span class="id">L2</span> -&gt; <span class="id">P</span> <span class="id">x</span> <span class="id">L1</span> -&gt; <span class="id">P</span> <span class="id">x</span> <span class="id">L2</span>) <span class="id">l</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Forall</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="kwd">exists</span> <span class="id">L</span>, <span class="id">P</span> <span class="id">x</span> <span class="id">L</span>) <span class="id">l</span> -&gt; <span class="kwd">exists</span> <span class="id">L</span>, <span class="id">Forall</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="id">P</span> <span class="id">x</span> <span class="id">L</span>) <span class="id">l</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">A</span> <span class="id">B</span> <span class="id">P</span> <span class="id">Hmono</span> <span class="id">l</span> <span class="id">H</span>. <span class="id">induction</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;- <span class="kwd">exists</span> <span class="id">nil</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;- <span class="id">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">L1</span> <span class="id">H1</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">IHForall</span> <span class="kwd">as</span> [<span class="id">L2</span> <span class="id">H2</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">L1</span> ++ <span class="id">L2</span>). <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">eapply</span> <span class="id">Hmono</span>; [|<span class="id">eassumption</span>]. <span class="id">prove_list_inc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">eapply</span> <span class="id">Forall_impl</span>; [|<span class="id">eassumption</span>]. <span class="id">simpl</span>. <span class="id">intros</span> <span class="id">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">Hmono</span>. <span class="id">prove_list_inc</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">lc_switch_bodies</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">m</span>, <span class="id">lc</span> (<span class="id">switch</span> <span class="id">t</span> <span class="id">m</span>) &lt;-&gt; <span class="id">lc</span> <span class="id">t</span> /\ <span class="id">Forall</span> (<span class="kwd">fun</span> '(<span class="id">p</span>, <span class="id">t2</span>) =&gt; <span class="id">bodies</span> <span class="id">p</span> <span class="id">t2</span>) <span class="id">m</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">m</span>. <span class="id">split</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">H</span>; <span class="id">inversion</span> <span class="id">H</span>; <span class="id">subst</span>. <span class="id">split</span>; [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">Forall_impl</span>; [|<span class="id">rewrite</span> <span class="id">Forall_forall</span>; <span class="id">intros</span> <span class="id">pt2</span> <span class="id">Hin</span>; <span class="id">refine</span> (<span class="kwd">fun</span> <span class="id">l</span> =&gt; <span class="id">_</span>); <span class="id">exact</span> (<span class="id">H3</span> (<span class="id">fst</span> <span class="id">pt2</span>) (<span class="id">snd</span> <span class="id">pt2</span>) <span class="id">l</span> <span class="id">ltac</span>:(<span class="id">destruct</span> <span class="id">pt2</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">assumption</span>))].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hbody</span>. <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="kwd">exists</span> <span class="id">L</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> [<span class="id">H1</span> <span class="id">H2</span>]. <span class="id">assert</span> (<span class="id">H3</span> : <span class="id">Forall</span> (<span class="kwd">fun</span> <span class="id">pt2</span> =&gt; <span class="id">bodies</span> (<span class="id">fst</span> <span class="id">pt2</span>) (<span class="id">snd</span> <span class="id">pt2</span>)) <span class="id">m</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">eapply</span> <span class="id">Forall_impl</span>; [|<span class="id">eassumption</span>]. <span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>]. <span class="id">simpl</span>. <span class="id">tauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">Forall_ex_mono_exchange</span> <span class="kwd">in</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">destruct</span> <span class="id">H3</span> <span class="kwd">as</span> [<span class="id">L</span> <span class="id">H3</span>]. <span class="id">apply</span> <span class="id">lc_switch</span> <span class="kwd">with</span> (<span class="id">L</span> := <span class="id">L</span>); [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H3</span>. <span class="id">intros</span> <span class="id">p</span> <span class="id">t2</span> <span class="id">l</span> <span class="id">Hin</span> <span class="id">Hdistinct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> (<span class="id">H3</span> (<span class="id">p</span>, <span class="id">t2</span>)); <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">L1</span> <span class="id">L2</span> <span class="id">Hinc</span> <span class="id">H</span> <span class="id">l</span> <span class="id">Hl</span>. <span class="id">apply</span> <span class="id">H</span>. <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">distinct_incl</span>; <span class="id">eassumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_lc_id_core</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span> <span class="id">v</span> <span class="id">k1</span> <span class="id">k2</span>, <span class="id">k1</span> &lt;&gt; <span class="id">k2</span> -&gt; <span class="id">t</span> [ <span class="id">k2</span> &lt;- <span class="id">v</span> ] [ <span class="id">k1</span> &lt;- <span class="id">u</span> ] = <span class="id">t</span> [ <span class="id">k2</span> &lt;- <span class="id">v</span> ] -&gt; <span class="id">t</span> [ <span class="id">k1</span> &lt;- <span class="id">u</span> ] = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>; <span class="id">intros</span> <span class="id">u</span> <span class="id">v</span> <span class="id">k1</span> <span class="id">k2</span> <span class="id">Hk</span> <span class="id">Heq</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">inversion</span> <span class="id">Heq</span>; <span class="id">try</span> (<span class="id">f_equal</span>; <span class="id">eauto</span>).<br/>
&nbsp;&nbsp;- <span class="id">repeat</span> ( <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>; <span class="id">simpl</span> <span class="kwd">in</span> * ); <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">erewrite</span> <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|<span class="id">rewrite</span> &lt;- <span class="id">Forall_forall</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">Forall2_map_eq</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">rewrite</span> <span class="id">Forall2_map_left</span>, <span class="id">Forall2_map_same</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">Forall_impl</span>; [|<span class="id">rewrite</span> &lt;- <span class="id">Forall_and</span>; <span class="id">split</span>; [<span class="id">apply</span> <span class="id">H</span> | <span class="id">apply</span> <span class="id">H1</span>]]. <span class="id">intros</span> <span class="id">t</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl</span>. <span class="id">intros</span> [<span class="id">Ht1</span> <span class="id">Ht2</span>]; <span class="id">eapply</span> <span class="id">Ht1</span>; <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">erewrite</span> <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|<span class="id">rewrite</span> &lt;- <span class="id">Forall_forall</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">Forall2_map_eq</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="id">rewrite</span> <span class="id">Forall2_map_left</span>, <span class="id">Forall2_map_same</span> <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">Forall_impl</span>; [|<span class="id">rewrite</span> &lt;- <span class="id">Forall_and</span>; <span class="id">split</span>; [<span class="id">apply</span> <span class="id">H</span> | <span class="id">apply</span> <span class="id">H2</span>]]. <span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl</span>. <span class="id">intros</span> [<span class="id">H3</span> <span class="id">H4</span>]; <span class="id">injection</span> <span class="id">H4</span> <span class="kwd">as</span> <span class="id">H4</span>. <span class="id">f_equal</span>; <span class="id">eapply</span> <span class="id">H3</span>; [|<span class="id">apply</span> <span class="id">H4</span>]. <span class="id">lia</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_list_lc_id_core</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span> <span class="id">l</span> <span class="id">k1</span> <span class="id">k2</span>, (<span class="id">k1</span> &lt; <span class="id">k2</span> \/ <span class="id">k2</span> + <span class="id">length</span> <span class="id">l</span> &lt;= <span class="id">k1</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">substb_list</span> <span class="id">k2</span> <span class="id">l</span> <span class="id">t</span>) [ <span class="id">k1</span> &lt;- <span class="id">u</span> ] = <span class="id">substb_list</span> <span class="id">k2</span> <span class="id">l</span> <span class="id">t</span> -&gt; <span class="id">t</span> [ <span class="id">k1</span> &lt;- <span class="id">u</span> ] = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">u</span> <span class="id">l</span>. <span class="id">revert</span> <span class="id">t</span>. <span class="id">induction</span> <span class="id">l</span> <span class="kwd">as</span> [|<span class="id">v</span> <span class="id">l</span>]; <span class="id">intros</span> <span class="id">t</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>. <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>. <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">eapply</span> <span class="id">substb_lc_id_core</span> <span class="kwd">in</span> <span class="id">H0</span>; [|<span class="id">lia</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">IHl</span>; [|<span class="id">eassumption</span>]. <span class="id">lia</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_lc_id</span> : <span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span>, <span class="id">lc</span> <span class="id">t</span> -&gt; <span class="kwd">forall</span> <span class="id">k</span>, <span class="id">t</span> [ <span class="id">k</span> &lt;- <span class="id">u</span> ] = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t1</span> <span class="id">t2</span> <span class="id">H</span>. <span class="id">induction</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;- <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>; <span class="id">rewrite</span> <span class="id">IHlc1</span>, <span class="id">IHlc2</span>; <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">k</span>. <span class="id">simpl</span>. <span class="id">f_equal</span>. <span class="id">pick</span> <span class="id">x</span> \<span class="id">notin</span> <span class="id">L</span> <span class="kwd">as</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">substb_lc_id_core</span> <span class="kwd">with</span> (<span class="id">k2</span> := 0); <span class="id">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">k</span>. <span class="id">simpl</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|]. <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span>; <span class="id">apply</span> <span class="id">H0</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">k</span>. <span class="id">simpl</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHlc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">erewrite</span> <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|]. <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> [<span class="id">p</span> <span class="id">t3</span>] <span class="id">Hin</span>. <span class="id">simpl</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pickn</span> <span class="id">p</span> <span class="id">distinct</span> <span class="id">l</span> \<span class="id">notin</span> <span class="id">L</span> <span class="kwd">as</span> <span class="id">Hl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">H1</span> <span class="kwd">in</span> <span class="id">Hin</span>; [|<span class="id">eassumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">substb_list_lc_id_core</span>; [|<span class="id">eassumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">map_length</span>, <span class="id">distinct_length</span> <span class="kwd">by</span> <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lia</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_substf</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span> <span class="id">v</span> <span class="id">k</span> <span class="id">x</span>, <span class="id">lc</span> <span class="id">u</span> -&gt; <span class="id">t</span> [ <span class="id">k</span> &lt;- <span class="id">v</span> ] [ <span class="id">x</span> := <span class="id">u</span> ] = <span class="id">t</span> [ <span class="id">x</span> := <span class="id">u</span> ] [ <span class="id">k</span> &lt;- <span class="id">v</span> [ <span class="id">x</span> := <span class="id">u</span> ]].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>; <span class="id">simpl</span>; <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; [|<span class="id">reflexivity</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substb_lc_id</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">f_equal</span>. <span class="id">apply</span> <span class="id">IHt</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">f_equal</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">f_equal</span>. <span class="id">rewrite</span> !<span class="id">map_map</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">map_ext_in</span>; <span class="id">rewrite</span> &lt;- <span class="id">Forall_forall</span>. <span class="id">eapply</span> <span class="id">Forall_impl</span>; [|<span class="id">eassumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl</span>. <span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>. <span class="id">apply</span> <span class="id">Ht</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">f_equal</span>; [<span class="id">apply</span> <span class="id">IHt</span>; <span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> !<span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>; <span class="id">rewrite</span> &lt;- <span class="id">Forall_forall</span>. <span class="id">eapply</span> <span class="id">Forall_impl</span>; [|<span class="id">eassumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>. <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">f_equal</span>. <span class="id">apply</span> <span class="id">Hpt2</span>. <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_list_substf</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">vs</span> <span class="id">t</span> <span class="id">u</span> <span class="id">k</span> <span class="id">x</span>, <span class="id">lc</span> <span class="id">u</span> -&gt; (<span class="id">substb_list</span> <span class="id">k</span> <span class="id">vs</span> <span class="id">t</span>) [ <span class="id">x</span> := <span class="id">u</span> ] = <span class="id">substb_list</span> <span class="id">k</span> (<span class="id">map</span> (<span class="id">substf</span> <span class="id">x</span> <span class="id">u</span>) <span class="id">vs</span>) (<span class="id">t</span> [ <span class="id">x</span> := <span class="id">u</span> ]).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">vs</span> <span class="kwd">as</span> [|<span class="id">v</span> <span class="id">vs</span>]; <span class="id">intros</span> <span class="id">t</span> <span class="id">u</span> <span class="id">k</span> <span class="id">x</span> <span class="id">Hlc</span>.<br/>
&nbsp;&nbsp;- <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">substb_substf</span> <span class="kwd">by</span> <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f_equal</span>. <span class="id">apply</span> <span class="id">IHvs</span>. <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substf_substb_free</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span> <span class="id">v</span> <span class="id">k</span> <span class="id">x</span>, <span class="id">x</span> ∉ <span class="id">fv</span> <span class="id">v</span> -&gt; <span class="id">lc</span> <span class="id">u</span> -&gt; <span class="id">t</span> [<span class="id">x</span> := <span class="id">u</span>] [<span class="id">k</span> &lt;- <span class="id">v</span>] = <span class="id">t</span> [<span class="id">k</span> &lt;- <span class="id">v</span>] [<span class="id">x</span> := <span class="id">u</span>].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span>. <span class="id">rewrite</span> <span class="id">substb_substf</span>; [|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;<span class="id">f_equal</span>. <span class="id">rewrite</span> <span class="id">substf_fv</span>; <span class="id">auto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substf_substb_list_free</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span> <span class="id">l</span> <span class="id">k</span> <span class="id">x</span>, (<span class="kwd">forall</span> <span class="id">v</span>, <span class="id">v</span> \<span class="kwd">in</span> <span class="id">l</span> -&gt; <span class="id">x</span> ∉ <span class="id">fv</span> <span class="id">v</span>) -&gt; <span class="id">lc</span> <span class="id">u</span> -&gt; <span class="id">substb_list</span> <span class="id">k</span> <span class="id">l</span> (<span class="id">t</span> [<span class="id">x</span> := <span class="id">u</span>]) = (<span class="id">substb_list</span> <span class="id">k</span> <span class="id">l</span> <span class="id">t</span>) [ <span class="id">x</span> := <span class="id">u</span> ].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">u</span> <span class="id">l</span>. <span class="id">revert</span> <span class="id">t</span>; <span class="id">induction</span> <span class="id">l</span> <span class="kwd">as</span> [|<span class="id">v</span> <span class="id">l</span>]; <span class="id">intros</span> <span class="id">t</span> <span class="id">k</span> <span class="id">x</span> <span class="id">Hl</span> <span class="id">Hlc</span>.<br/>
&nbsp;&nbsp;- <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">IHl</span>; [|<span class="id">intros</span> <span class="id">v2</span> <span class="id">Hv2</span>; <span class="id">apply</span> <span class="id">Hl</span>; <span class="id">simpl</span>; <span class="id">right</span>; <span class="id">assumption</span>|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">substf_substb_free</span>; [<span class="id">apply</span> <span class="id">Hl</span>; <span class="id">simpl</span>; <span class="id">tauto</span>|<span class="id">assumption</span>].<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substf_substb_free2</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span> <span class="id">v</span> <span class="id">k</span> <span class="id">x</span>, <span class="id">x</span> ∉ <span class="id">fv</span> <span class="id">t</span> -&gt; <span class="id">t</span> [<span class="id">k</span> &lt;- <span class="id">v</span>] [<span class="id">x</span> := <span class="id">u</span>] = <span class="id">t</span> [<span class="id">k</span> &lt;- <span class="id">v</span> [<span class="id">x</span> := <span class="id">u</span>]].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>; <span class="id">simpl</span>; <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">intuition</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">f_equal</span>. <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f_equal</span>; [<span class="id">apply</span> <span class="id">IHt1</span> | <span class="id">apply</span> <span class="id">IHt2</span>]; <span class="id">rewrite</span> !<span class="id">in_app_iff</span> <span class="kwd">in</span> *; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">u</span> <span class="id">v</span> <span class="id">k</span> <span class="id">x</span> <span class="id">Hx</span>. <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">f_equal</span>. <span class="id">rewrite</span> <span class="id">map_map</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">map_ext_in</span>; <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>; <span class="id">apply</span> <span class="id">H</span>; [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">concat_In</span> <span class="kwd">in</span> <span class="id">Hx</span>. <span class="id">intros</span> <span class="id">Hx2</span>; <span class="id">apply</span> <span class="id">Hx</span>. <span class="kwd">exists</span> (<span class="id">fv</span> <span class="id">t</span>). <span class="id">split</span>; [<span class="id">assumption</span>|<span class="id">apply</span> <span class="id">in_map</span>; <span class="id">assumption</span>].<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">u</span> <span class="id">v</span> <span class="id">k</span> <span class="id">x</span> <span class="id">Hx</span>. <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">Hx</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHt</span>. <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">rewrite</span> <span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>; <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hin</span>. <span class="id">f_equal</span>; <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">Hx2</span>; <span class="id">apply</span> <span class="id">Hx</span>; <span class="id">right</span>. <span class="id">rewrite</span> <span class="id">concat_In</span>. <span class="kwd">exists</span> (<span class="id">fv</span> <span class="id">t2</span>). <span class="id">split</span>; [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">in_map_iff</span>. <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">simpl</span>. <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeb_id</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">x</span>, <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">t</span> -&gt; <span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span> = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span>. <span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">firstorder</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">rewrite</span> <span class="id">IHt</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span>*; <span class="id">f_equal</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">f_equal</span>. <span class="id">erewrite</span> <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>. <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">apply</span> <span class="id">H</span>; [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">Hx</span>. <span class="id">apply</span> <span class="id">H0</span>. <span class="id">rewrite</span> <span class="id">concat_In</span>. <span class="kwd">exists</span> (<span class="id">fv</span> <span class="id">t</span>); <span class="id">split</span>; [<span class="id">assumption</span>|<span class="id">apply</span> <span class="id">in_map</span>; <span class="id">assumption</span>].<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHt</span>. <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">erewrite</span> <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|]. <span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>; <span class="id">simpl</span>; <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="id">intros</span> <span class="id">Hx</span>; <span class="id">apply</span> <span class="id">H0</span>; <span class="id">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">concat_In</span>. <span class="kwd">exists</span> (<span class="id">fv</span> <span class="id">t2</span>); <span class="id">split</span>; [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">in_map_iff</span>; <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">simpl</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeb_substf_free</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span> <span class="id">k</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">x</span> &lt;&gt; <span class="id">y</span> -&gt; <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">u</span> -&gt; (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span>) [<span class="id">y</span> := <span class="id">u</span>] = <span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> (<span class="id">t</span> [<span class="id">y</span> := <span class="id">u</span>]).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span>. <span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>; <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>; <span class="id">repeat</span> (<span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">simpl</span> <span class="kwd">in</span> * ); <span class="id">try</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">closeb_id</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">f_equal</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">f_equal</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">f_equal</span>. <span class="id">rewrite</span> !<span class="id">map_map</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">map_ext_in</span>. <span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> <span class="id">H</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHt</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">rewrite</span> !<span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>. <span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substf_lc</span> : <span class="kwd">forall</span> <span class="id">t</span>, <span class="id">lc</span> <span class="id">t</span> -&gt; <span class="kwd">forall</span> <span class="id">u</span> <span class="id">x</span>, <span class="id">lc</span> <span class="id">u</span> -&gt; <span class="id">lc</span> (<span class="id">t</span> [<span class="id">x</span> := <span class="id">u</span>]).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>. <span class="id">induction</span> <span class="id">Ht</span>; <span class="id">intros</span> <span class="id">u</span> <span class="id">x</span> <span class="id">Hu</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; [<span class="id">assumption</span> | <span class="id">constructor</span>].<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">constructor</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">apply</span> <span class="id">lc_lam</span> <span class="kwd">with</span> (<span class="id">L</span> := <span class="id">x</span> :: <span class="id">L</span>). <span class="id">intros</span> <span class="id">y</span> <span class="id">Hy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substf_substb_free</span>; [|<span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">intuition</span> <span class="id">congruence</span>|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">H0</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>. <span class="id">rewrite</span> <span class="id">in_map_iff</span> <span class="kwd">in</span> <span class="id">Ht</span>. <span class="id">destruct</span> <span class="id">Ht</span> <span class="kwd">as</span> (<span class="id">t1</span> &amp; &lt;- &amp; <span class="id">Ht1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">H0</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">apply</span> <span class="id">lc_switch</span> <span class="kwd">with</span> (<span class="id">L</span> := <span class="id">x</span> :: <span class="id">L</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHHt</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> <span class="id">p</span> <span class="id">t2</span> <span class="id">l</span> <span class="id">Hpt2</span> <span class="id">Hl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">in_map_iff</span> <span class="kwd">in</span> <span class="id">Hpt2</span>. <span class="id">destruct</span> <span class="id">Hpt2</span> <span class="kwd">as</span> ([<span class="id">p2</span> <span class="id">t3</span>] &amp; <span class="id">Heq</span> &amp; <span class="id">Hpt3</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">injection</span> <span class="id">Heq</span> <span class="kwd">as</span> -&gt; &lt;-.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substf_substb_list_free</span>; [| |<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">eapply</span> <span class="id">H0</span>; [<span class="id">eassumption</span>| |<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">distinct_incl</span>; [|<span class="id">eassumption</span>]. <span class="id">prove_list_inc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">intros</span> <span class="id">v</span> <span class="id">Hv</span>. <span class="id">rewrite</span> <span class="id">in_map_iff</span> <span class="kwd">in</span> <span class="id">Hv</span>. <span class="id">destruct</span> <span class="id">Hv</span> <span class="kwd">as</span> (<span class="id">x1</span> &amp; &lt;- &amp; <span class="id">Hx1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl</span>. <span class="id">intros</span> [-&gt; | []]. <span class="id">eapply</span> <span class="id">distinct_distinct</span>; [<span class="id">eassumption</span>| |<span class="id">eassumption</span>]; <span class="id">simpl</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_is_substf</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span> <span class="id">x</span>, <span class="id">x</span> ∉ <span class="id">fv</span> <span class="id">t</span> -&gt; <span class="id">t</span> ^^ <span class="id">u</span> = <span class="id">t</span> ^ <span class="id">x</span> [<span class="id">x</span> := <span class="id">u</span>].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">u</span> <span class="id">x</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substf_substb_free2</span>; [|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;<span class="id">simpl</span>. <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_lc</span> : <span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span>, <span class="id">body</span> <span class="id">t</span> -&gt; <span class="id">lc</span> <span class="id">u</span> -&gt; <span class="id">lc</span> (<span class="id">t</span> ^^ <span class="id">u</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">u</span> [<span class="id">L</span> <span class="id">Ht</span>] <span class="id">Hu</span>.<br/>
&nbsp;&nbsp;<span class="id">pick</span> <span class="id">fresh</span> <span class="id">x</span> <span class="kwd">as</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substb_is_substf</span> <span class="kwd">with</span> (<span class="id">x</span> := <span class="id">x</span>) <span class="kwd">by</span> (<span class="id">use_fresh</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span> <span class="id">substf_lc</span>; [<span class="id">apply</span> <span class="id">Ht</span>; <span class="id">use_fresh</span> <span class="id">x</span> | <span class="id">apply</span> <span class="id">Hu</span>].<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">exact</span> <span class="id">nil</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">lc_open_gen</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">x</span>, <span class="id">body</span> <span class="id">t</span> -&gt; <span class="id">lc</span> (<span class="id">t</span> ^ <span class="id">x</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span> <span class="id">substb_lc</span>; [<span class="id">assumption</span> | <span class="id">constructor</span>].<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_fv</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">u</span>, <span class="id">fv</span> (<span class="id">t</span> [ <span class="id">k</span> &lt;- <span class="id">u</span> ]) \<span class="id">subseteq</span> <span class="id">fv</span> <span class="id">t</span> ++ <span class="id">fv</span> <span class="id">u</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>; <span class="id">intros</span> <span class="id">k</span> <span class="id">u</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>; <span class="id">simpl</span>; <span class="id">prove_list_inc</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">prove_list_inc</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">apply</span> <span class="id">IHt</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">IHt1</span>, <span class="id">IHt2</span>. <span class="id">prove_list_inc</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">map_map</span>. <span class="id">intros</span> <span class="id">x</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">in_app_iff</span>, <span class="id">concat_map_In</span>. <span class="id">rewrite</span> <span class="id">concat_map_In</span> <span class="kwd">in</span> <span class="id">Hx</span>. <span class="id">destruct</span> <span class="id">Hx</span> <span class="kwd">as</span> (<span class="id">t</span> &amp; <span class="id">Hx</span> &amp; <span class="id">Ht</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">eapply</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">Hx</span>; [|<span class="id">assumption</span>]. <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">Hx</span>; <span class="id">destruct</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">left</span>. <span class="kwd">exists</span> <span class="id">t</span>. <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">map_map</span>. <span class="id">rewrite</span> <span class="id">IHt</span>. <span class="id">intros</span> <span class="id">x</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> !<span class="id">in_app_iff</span> <span class="kwd">in</span> *; <span class="id">destruct</span> <span class="id">Hx</span> <span class="kwd">as</span> [<span class="id">Hx</span> | <span class="id">Hx</span>]; [<span class="id">tauto</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">concat_map_In</span> <span class="kwd">in</span> *. <span class="id">destruct</span> <span class="id">Hx</span> <span class="kwd">as</span> ([<span class="id">p</span> <span class="id">t2</span>] &amp; <span class="id">Hx</span> &amp; <span class="id">Hpt2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">eapply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)) <span class="kwd">in</span> <span class="id">Hx</span>; [|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">Hx</span>; <span class="id">destruct</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">left</span>. <span class="id">right</span>. <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>). <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_fv2</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">u</span>, <span class="id">fv</span> <span class="id">t</span> \<span class="id">subseteq</span> <span class="id">fv</span> (<span class="id">t</span> [ <span class="id">k</span> &lt;- <span class="id">u</span> ]).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">prove_list_inc</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">apply</span> <span class="id">IHt</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">rewrite</span> &lt;- <span class="id">IHt1</span>, &lt;- <span class="id">IHt2</span>. <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">intros</span> <span class="id">x</span> <span class="id">Hx</span>. <span class="id">rewrite</span> <span class="id">concat_map_In</span> <span class="kwd">in</span> *. <span class="id">destruct</span> <span class="id">Hx</span> <span class="kwd">as</span> (<span class="id">t</span> &amp; <span class="id">Hx</span> &amp; <span class="id">Ht</span>). <span class="kwd">exists</span> (<span class="id">substb</span> <span class="id">k</span> <span class="id">u</span> <span class="id">t</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">split</span>; [|<span class="id">apply</span> <span class="id">in_map</span>; <span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> <span class="id">H</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">intros</span> <span class="id">x</span> <span class="id">Hx</span>. <span class="id">rewrite</span> <span class="id">in_app_iff</span>, <span class="id">concat_map_In</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">Hx</span> <span class="kwd">as</span> [<span class="id">Hx</span> | ([<span class="id">p</span> <span class="id">t2</span>] &amp; <span class="id">Hx</span> &amp; <span class="id">Hpt2</span>)].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">left</span>. <span class="id">apply</span> <span class="id">IHt</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">right</span>. <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">substb</span> (<span class="id">p</span> + <span class="id">k</span>) <span class="id">u</span> <span class="id">t2</span>). <span class="id">split</span>; [|<span class="id">rewrite</span> <span class="id">in_map_iff</span>; <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">tauto</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_list_fv</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">us</span> <span class="id">t</span> <span class="id">k</span> <span class="id">x</span>, (<span class="kwd">forall</span> <span class="id">u</span>, <span class="id">u</span> \<span class="kwd">in</span> <span class="id">us</span> -&gt; <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">u</span>) -&gt; <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">t</span> -&gt; <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> (<span class="id">substb_list</span> <span class="id">k</span> <span class="id">us</span> <span class="id">t</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">us</span> <span class="kwd">as</span> [|<span class="id">u</span> <span class="id">us</span>].<br/>
&nbsp;&nbsp;- <span class="id">intros</span>. <span class="id">simpl</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>. <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">substb_fv</span>, <span class="id">notin_app_iff</span>. <span class="id">split</span>; [|<span class="id">apply</span> <span class="id">H</span>; <span class="id">simpl</span>; <span class="id">tauto</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">IHus</span>; [<span class="id">intros</span>; <span class="id">apply</span> <span class="id">H</span>; <span class="id">simpl</span>; <span class="id">tauto</span>|<span class="id">assumption</span>].<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_list_fv2</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">us</span> <span class="id">t</span> <span class="id">k</span>, <span class="id">fv</span> <span class="id">t</span> \<span class="id">subseteq</span> <span class="id">fv</span> (<span class="id">substb_list</span> <span class="id">k</span> <span class="id">us</span> <span class="id">t</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">us</span> <span class="kwd">as</span> [|<span class="id">u</span> <span class="id">us</span>].<br/>
&nbsp;&nbsp;- <span class="id">intros</span>. <span class="id">simpl</span>. <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>. <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">IHus</span>. <span class="id">apply</span> <span class="id">substb_fv2</span>.<br/>
Qed.</details>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_open</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">x</span>, <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">t</span> -&gt; <span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> (<span class="id">t</span> [<span class="id">k</span> &lt;- <span class="id">fvar</span> <span class="id">x</span>]) = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span>. <span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>; <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>; <span class="id">simpl</span>; <span class="id">try</span> <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">firstorder</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">rewrite</span> <span class="id">IHt</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> *; <span class="id">rewrite</span> <span class="id">IHt1</span>, <span class="id">IHt2</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f_equal</span>. <span class="id">erewrite</span> <span class="id">map_map</span>, <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>. <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> <span class="id">H</span>; [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">concat_map_In</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">intros</span> <span class="id">Hx</span>; <span class="id">apply</span> <span class="id">H0</span>; <span class="kwd">exists</span> <span class="id">t</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> *. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHt</span>. <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">erewrite</span> <span class="id">map_map</span>, <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>. <span class="id">simpl</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">Hx</span>; <span class="id">apply</span> <span class="id">H0</span>; <span class="id">right</span>. <span class="id">rewrite</span> <span class="id">concat_map_In</span>. <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">simpl</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">close_open_list</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">xs</span> <span class="id">t</span> <span class="id">k</span> <span class="id">p</span>, <span class="id">distinct</span> (<span class="id">fv</span> <span class="id">t</span>) <span class="id">p</span> <span class="id">xs</span> -&gt; <span class="id">closeb_list</span> <span class="id">k</span> <span class="id">xs</span> (<span class="id">substb_list</span> <span class="id">k</span> (<span class="id">map</span> <span class="id">fvar</span> <span class="id">xs</span>) <span class="id">t</span>) = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">xs</span> <span class="kwd">as</span> [|<span class="id">x</span> <span class="id">xs</span>].<br/>
&nbsp;&nbsp;- <span class="id">intros</span>. <span class="id">simpl</span>. <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">t</span> <span class="id">k</span> <span class="id">p</span> <span class="id">H</span>. <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">H</span>; <span class="id">subst</span>. <span class="id">rewrite</span> <span class="id">close_open</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">eapply</span> <span class="id">IHxs</span>. <span class="id">eapply</span> <span class="id">distinct_incl</span>; [|<span class="id">eassumption</span>]. <span class="id">prove_list_inc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">substb_list_fv</span>; [|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">forall_map</span>. <span class="id">intros</span> <span class="id">y</span> <span class="id">Hy</span> [-&gt;|[]]. <span class="id">eapply</span> <span class="id">distinct_distinct</span>; [| |<span class="id">apply</span> <span class="id">Hy</span>]; [<span class="id">eassumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl</span>. <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_inj</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">t1</span> <span class="id">t2</span>, <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">t1</span> -&gt; <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">t2</span> -&gt; <span class="id">t1</span> ^ <span class="id">x</span> = <span class="id">t2</span> ^ <span class="id">x</span> -&gt; <span class="id">t1</span> = <span class="id">t2</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> &lt;- (<span class="id">close_open</span> <span class="id">t1</span> 0 <span class="id">x</span>), &lt;- (<span class="id">close_open</span> <span class="id">t2</span> 0 <span class="id">x</span>); <span class="id">auto</span>; <span class="id">congruence</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_close_core</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">i</span> <span class="id">j</span> <span class="id">x</span> <span class="id">y</span> <span class="id">u</span>, <span class="id">i</span> &lt;&gt; <span class="id">j</span> -&gt; <span class="id">x</span> &lt;&gt; <span class="id">y</span> -&gt; <span class="id">lc</span> <span class="id">u</span> -&gt; <span class="id">y</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">t</span> -&gt; (<span class="id">closeb</span> <span class="id">j</span> <span class="id">x</span> <span class="id">t</span>) [<span class="id">j</span> &lt;- <span class="id">u</span>] [<span class="id">i</span> &lt;- <span class="id">fvar</span> <span class="id">y</span>] = (<span class="id">closeb</span> <span class="id">j</span> <span class="id">x</span> (<span class="id">t</span> [<span class="id">i</span> &lt;- <span class="id">fvar</span> <span class="id">y</span>])) [<span class="id">j</span> &lt;- <span class="id">u</span>].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span>. <span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">repeat</span> ((<span class="id">destruct</span> <span class="id">Nat.eq_dec</span> || <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>); <span class="id">simpl</span>); <span class="id">try</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substb_lc_id</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">repeat</span> ((<span class="id">destruct</span> <span class="id">Nat.eq_dec</span> || <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>); <span class="id">simpl</span>); <span class="id">try</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substb_lc_id</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">IHt</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f_equal</span>; [<span class="id">apply</span> <span class="id">IHt1</span> | <span class="id">apply</span> <span class="id">IHt2</span>]; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> !<span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>. <span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">apply</span> <span class="id">H</span>; <span class="id">try</span> <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">Hy</span>. <span class="id">apply</span> <span class="id">H3</span>. <span class="id">rewrite</span> <span class="id">concat_map_In</span>. <span class="kwd">exists</span> <span class="id">t</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> *. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHt</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">rewrite</span> !<span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>. <span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); <span class="id">try</span> <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">intros</span> <span class="id">Hy</span>. <span class="id">apply</span> <span class="id">H3</span>. <span class="id">right</span>. <span class="id">rewrite</span> <span class="id">concat_map_In</span>. <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">simpl</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_list_inj</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span> <span class="id">k</span> <span class="id">n</span> <span class="id">t1</span> <span class="id">t2</span>, <span class="id">distinct</span> (<span class="id">fv</span> <span class="id">t1</span> ++ <span class="id">fv</span> <span class="id">t2</span>) <span class="id">n</span> <span class="id">l</span> -&gt; <span class="id">substb_list</span> <span class="id">k</span> (<span class="id">map</span> <span class="id">fvar</span> <span class="id">l</span>) <span class="id">t1</span> = <span class="id">substb_list</span> <span class="id">k</span> (<span class="id">map</span> <span class="id">fvar</span> <span class="id">l</span>) <span class="id">t2</span> -&gt; <span class="id">t1</span> = <span class="id">t2</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">l</span> <span class="kwd">as</span> [|<span class="id">x</span> <span class="id">l</span>].<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">inversion</span> <span class="id">H</span>; <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">IHl</span>; [<span class="id">eapply</span> <span class="id">distinct_incl</span>; [|<span class="id">eassumption</span>]; <span class="id">prove_list_inc</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">close_open</span> <span class="kwd">with</span> (<span class="id">t</span> := <span class="id">substb_list</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>), <span class="id">H0</span>, <span class="id">close_open</span>; [<span class="id">reflexivity</span>| |].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">substb_list_fv</span>; [|<span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> *; <span class="id">tauto</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">u</span> <span class="id">Hu</span>; <span class="id">rewrite</span> <span class="id">in_map_iff</span> <span class="kwd">in</span> <span class="id">Hu</span>; <span class="id">destruct</span> <span class="id">Hu</span> <span class="kwd">as</span> (<span class="id">y</span> &amp; &lt;- &amp; <span class="id">Hy</span>); <span class="id">apply</span> <span class="id">notin_one</span>; <span class="id">intros</span> -&gt;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">distinct_distinct</span>; [| |<span class="id">eassumption</span>]; [<span class="id">eassumption</span>|]; <span class="id">simpl</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">substb_list_fv</span>; [|<span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> *; <span class="id">tauto</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">u</span> <span class="id">Hu</span>; <span class="id">rewrite</span> <span class="id">in_map_iff</span> <span class="kwd">in</span> <span class="id">Hu</span>; <span class="id">destruct</span> <span class="id">Hu</span> <span class="kwd">as</span> (<span class="id">y</span> &amp; &lt;- &amp; <span class="id">Hy</span>); <span class="id">apply</span> <span class="id">notin_one</span>; <span class="id">intros</span> -&gt;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">distinct_distinct</span>; [| |<span class="id">eassumption</span>]; [<span class="id">eassumption</span>|]; <span class="id">simpl</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_close_core_list</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">i</span> <span class="id">j</span> <span class="id">p</span> <span class="id">x</span> <span class="id">ys</span> <span class="id">u</span>, (<span class="id">j</span> &lt; <span class="id">i</span> \/ <span class="id">i</span> + <span class="id">p</span> &lt;= <span class="id">j</span>) -&gt; <span class="id">distinct</span> (<span class="id">x</span> :: <span class="id">fv</span> <span class="id">t</span>) <span class="id">p</span> <span class="id">ys</span> -&gt; <span class="id">lc</span> <span class="id">u</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">substb_list</span> <span class="id">i</span> (<span class="id">map</span> <span class="id">fvar</span> <span class="id">ys</span>) ((<span class="id">closeb</span> <span class="id">j</span> <span class="id">x</span> <span class="id">t</span>) [<span class="id">j</span> &lt;- <span class="id">u</span>]) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">closeb</span> <span class="id">j</span> <span class="id">x</span> (<span class="id">substb_list</span> <span class="id">i</span> (<span class="id">map</span> <span class="id">fvar</span> <span class="id">ys</span>) <span class="id">t</span>)) [<span class="id">j</span> &lt;- <span class="id">u</span>].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">i</span> <span class="id">j</span> <span class="id">p</span> <span class="id">x</span> <span class="id">ys</span> <span class="id">u</span>. <span class="id">revert</span> <span class="id">t</span> <span class="id">i</span> <span class="id">j</span> <span class="id">p</span> <span class="id">x</span> <span class="id">u</span>; <span class="id">induction</span> <span class="id">ys</span> <span class="kwd">as</span> [|<span class="id">y</span> <span class="id">ys</span>]; <span class="id">intros</span> <span class="id">t</span> <span class="id">i</span> <span class="id">j</span> <span class="id">p</span> <span class="id">x</span> <span class="id">u</span> <span class="id">Hij</span> <span class="id">Hys</span> <span class="id">Hlc</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">Hys</span>; <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">IHys</span>; [| |<span class="id">eapply</span> <span class="id">distinct_incl</span>; [|<span class="id">eassumption</span>]; <span class="id">prove_list_inc</span>|<span class="id">assumption</span>]; [|<span class="id">lia</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">open_close_core</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> -&gt;; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">substb_list_fv</span>; [|<span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">tauto</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">v</span> <span class="id">Hv</span>; <span class="id">rewrite</span> <span class="id">in_map_iff</span> <span class="kwd">in</span> <span class="id">Hv</span>; <span class="id">destruct</span> <span class="id">Hv</span> <span class="kwd">as</span> (<span class="id">z</span> &amp; &lt;- &amp; <span class="id">Hz</span>); <span class="id">apply</span> <span class="id">notin_one</span>; <span class="id">intros</span> -&gt;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">distinct_distinct</span>; [| |<span class="id">eassumption</span>]; [<span class="id">eassumption</span>|]; <span class="id">simpl</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_close</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span>, <span class="id">lc</span> <span class="id">t</span> -&gt; <span class="kwd">forall</span> <span class="id">k</span> <span class="id">x</span> <span class="id">u</span>, <span class="id">lc</span> <span class="id">u</span> -&gt; <span class="id">substb</span> <span class="id">k</span> <span class="id">u</span> (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span>) = <span class="id">t</span> [<span class="id">x</span> := <span class="id">u</span>].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">H</span>. <span class="id">induction</span> <span class="id">H</span>; <span class="id">intros</span> <span class="id">k</span> <span class="id">x</span> <span class="id">u</span> <span class="id">Hu</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">simpl</span>; <span class="id">try</span> <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>; <span class="id">simpl</span>; <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">f_equal</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pick</span> <span class="id">fresh</span> <span class="id">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> (<span class="id">open_inj</span> <span class="id">y</span>); <span class="id">try</span> <span class="id">use_fresh</span> <span class="id">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">open_close_core</span> <span class="kwd">by</span> (<span class="id">use_fresh</span> <span class="id">y</span> || <span class="id">tauto</span> || <span class="id">discriminate</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substf_substb_free</span> <span class="kwd">by</span> (<span class="id">assumption</span> || <span class="id">apply</span> <span class="id">notin_one</span>; <span class="id">use_fresh</span> <span class="id">y</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">H0</span>; [<span class="id">use_fresh</span> <span class="id">y</span> | <span class="id">assumption</span>].<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">f_equal</span>. <span class="id">rewrite</span> <span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>. <span class="id">apply</span> <span class="id">H0</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHlc</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">rewrite</span> <span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pickn</span> <span class="id">p</span> <span class="id">distinct</span> <span class="id">xs</span> \<span class="id">notin</span> (<span class="id">x</span> :: <span class="id">L</span> ++ <span class="id">fv</span> <span class="id">t2</span> ++ <span class="id">fv</span> (<span class="id">closeb</span> (<span class="id">p</span> + <span class="id">k</span>) <span class="id">x</span> <span class="id">t2</span> [<span class="id">p</span> + <span class="id">k</span> &lt;- <span class="id">u</span>]) ++ <span class="id">fv</span> (<span class="id">t2</span> [<span class="id">x</span> := <span class="id">u</span>])) <span class="kwd">as</span> <span class="id">Hxs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">open_list_inj</span> <span class="kwd">with</span> (<span class="id">l</span> := <span class="id">xs</span>) (<span class="id">k</span> := 0) (<span class="id">n</span> := <span class="id">p</span>); [<span class="id">eapply</span> <span class="id">distinct_incl</span>; [|<span class="id">eassumption</span>]; <span class="id">prove_list_inc</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H1</span> <span class="id">p</span> <span class="id">t2</span> <span class="id">xs</span> <span class="id">Hpt2</span> <span class="id">ltac</span>:(<span class="id">eapply</span> <span class="id">distinct_incl</span>; [|<span class="id">eassumption</span>]; <span class="id">prove_list_inc</span>) (<span class="id">p</span> + <span class="id">k</span>) <span class="id">x</span> <span class="id">u</span> <span class="id">Hu</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substf_substb_list_free</span>; [| |<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">rewrite</span> &lt;- <span class="id">H1</span>. <span class="id">eapply</span> <span class="id">open_close_core_list</span>; [|<span class="id">eapply</span> <span class="id">distinct_incl</span>; [|<span class="id">eassumption</span>]|]; [<span class="id">lia</span>|<span class="id">prove_list_inc</span>|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">intros</span> <span class="id">v</span> <span class="id">Hv</span>; <span class="id">rewrite</span> <span class="id">in_map_iff</span> <span class="kwd">in</span> <span class="id">Hv</span>; <span class="id">destruct</span> <span class="id">Hv</span> <span class="kwd">as</span> (<span class="id">y</span> &amp; &lt;- &amp; <span class="id">Hy</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> [-&gt; | []]. <span class="id">eapply</span> <span class="id">distinct_distinct</span>; [<span class="id">eassumption</span>| |<span class="id">eassumption</span>]. <span class="id">simpl</span>. <span class="id">tauto</span>.<br/>
<span class="id">Unshelve</span>. <span class="id">all</span>: <span class="id">exact</span> <span class="id">nil</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substf_id</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">t</span>, <span class="id">t</span> [<span class="id">x</span> := <span class="id">fvar</span> <span class="id">x</span>] = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">x</span> <span class="id">t</span>; <span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>; <span class="id">simpl</span>; <span class="id">try</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">f_equal</span>. <span class="id">erewrite</span> <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|]. <span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> <span class="id">H</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">f_equal</span>; [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|]. <span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f_equal</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)). <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_close_var</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span>, <span class="id">lc</span> <span class="id">t</span> -&gt; <span class="kwd">forall</span> <span class="id">k</span> <span class="id">x</span>, <span class="id">substb</span> <span class="id">k</span> (<span class="id">fvar</span> <span class="id">x</span>) (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span>) = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span>. <span class="id">rewrite</span> <span class="id">open_close</span>, <span class="id">substf_id</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">fv_substf_iff</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">x</span> <span class="id">y</span> <span class="id">u</span>, <span class="id">y</span> \<span class="kwd">in</span> <span class="id">fv</span> (<span class="id">t</span> [ <span class="id">x</span> := <span class="id">u</span> ]) &lt;-&gt; (<span class="id">y</span> \<span class="kwd">in</span> <span class="id">fv</span> <span class="id">t</span> /\ <span class="id">y</span> &lt;&gt; <span class="id">x</span>) \/ (<span class="id">x</span> \<span class="kwd">in</span> <span class="id">fv</span> <span class="id">t</span> /\ <span class="id">y</span> \<span class="kwd">in</span> <span class="id">fv</span> <span class="id">u</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">subst</span>. <span class="id">intuition</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">simpl</span>. <span class="id">intuition</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">apply</span> <span class="id">IHt</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">rewrite</span> !<span class="id">in_app_iff</span>, <span class="id">IHt1</span>, <span class="id">IHt2</span>. <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">rewrite</span> <span class="id">map_map</span>, !<span class="id">concat_map_In</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> (<span class="id">t</span> &amp; <span class="id">Hy</span> &amp; <span class="id">Ht</span>). <span class="id">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">Hy</span> <span class="kwd">by</span> <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">Hy</span>; [<span class="id">left</span> | <span class="id">right</span>]; <span class="id">split</span>; <span class="id">try</span> (<span class="kwd">exists</span> <span class="id">t</span>); <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> [[(<span class="id">t</span> &amp; <span class="id">Hy1</span> &amp; <span class="id">Ht</span>) <span class="id">Hy2</span>] | [(<span class="id">t</span> &amp; <span class="id">Hx</span> &amp; <span class="id">Ht</span>) <span class="id">Hy</span>]]; <span class="kwd">exists</span> <span class="id">t</span>; <span class="id">rewrite</span> <span class="id">H</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">rewrite</span> <span class="id">map_map</span>, !<span class="id">in_app_iff</span>, !<span class="id">concat_map_In</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">rewrite</span> <span class="id">IHt</span>. <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> [<span class="id">Hy</span> | ([<span class="id">p</span> <span class="id">t2</span>] &amp; <span class="id">Hy</span> &amp; <span class="id">Hpt2</span>)]; [<span class="id">tauto</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>) <span class="id">Hpt2</span>). <span class="id">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">Hy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">Hy</span>; [<span class="id">left</span> | <span class="id">right</span>]; <span class="id">split</span>; <span class="id">try</span> (<span class="id">right</span>; <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>)); <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> [[[<span class="id">Hy1</span> | ([<span class="id">p</span> <span class="id">t2</span>] &amp; <span class="id">Hy1</span> &amp; <span class="id">Hpt2</span>)] <span class="id">Hy2</span>] | [[<span class="id">Hx</span> | ([<span class="id">p</span> <span class="id">t2</span>] &amp; <span class="id">Hx</span> &amp; <span class="id">Hpt2</span>)] <span class="id">Hy</span>]];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">try</span> <span class="id">tauto</span>; <span class="id">specialize</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>) <span class="id">Hpt2</span>); <span class="id">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">right</span>; <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">rewrite</span> <span class="id">H</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">fv_substf</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">t</span> <span class="id">u</span>, <span class="id">fv</span> (<span class="id">t</span> [ <span class="id">x</span> := <span class="id">u</span> ]) \<span class="id">subseteq</span> <span class="id">fv</span> <span class="id">t</span> ++ <span class="id">fv</span> <span class="id">u</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">x</span> <span class="id">t</span> <span class="id">u</span> <span class="id">y</span>. <span class="id">rewrite</span> <span class="id">fv_substf_iff</span>, <span class="id">in_app_iff</span>. <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">fv_substf2</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">x</span> <span class="id">u</span>, <span class="id">fv</span> <span class="id">t</span> \<span class="id">subseteq</span> <span class="id">x</span> :: <span class="id">fv</span> (<span class="id">t</span> [ <span class="id">x</span> := <span class="id">u</span> ]).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">x</span> <span class="id">u</span> <span class="id">y</span>. <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">fv_substf_iff</span>.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> (<span class="id">freevar_eq_dec</span> <span class="id">x</span> <span class="id">y</span>); <span class="id">intuition</span> <span class="id">congruence</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">fv_substf3</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">x</span> <span class="id">u</span>, <span class="id">list_remove</span> <span class="id">x</span> (<span class="id">fv</span> <span class="id">t</span>) \<span class="id">subseteq</span> <span class="id">fv</span> (<span class="id">t</span> [ <span class="id">x</span> := <span class="id">u</span> ]).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">x</span> <span class="id">u</span> <span class="id">y</span>. <span class="id">rewrite</span> <span class="id">list_remove_correct</span>, <span class="id">fv_substf_iff</span>.<br/>
&nbsp;&nbsp;<span class="id">intuition</span> <span class="id">congruence</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">fv_substf4</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">x</span> <span class="id">u</span>, <span class="id">x</span> \<span class="kwd">in</span> <span class="id">fv</span> <span class="id">t</span> -&gt; <span class="id">fv</span> <span class="id">u</span> \<span class="id">subseteq</span> <span class="id">fv</span> (<span class="id">t</span> [ <span class="id">x</span> := <span class="id">u</span> ]).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">x</span> <span class="id">u</span> <span class="id">Hx</span> <span class="id">y</span>. <span class="id">rewrite</span> <span class="id">fv_substf_iff</span>. <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substf_substf</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">x1</span> <span class="id">x2</span> <span class="id">u1</span> <span class="id">u2</span>, <span class="id">x1</span> &lt;&gt; <span class="id">x2</span> -&gt; <span class="id">x1</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">u2</span> -&gt; <span class="id">t</span> [ <span class="id">x1</span> := <span class="id">u1</span> ] [ <span class="id">x2</span> := <span class="id">u2</span> ] = <span class="id">t</span> [ <span class="id">x2</span> := <span class="id">u2</span> ] [ <span class="id">x1</span> := <span class="id">u1</span> [ <span class="id">x2</span> := <span class="id">u2</span> ] ].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">repeat</span> (<span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">simpl</span> <span class="kwd">in</span> * ); <span class="id">try</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substf_fv</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">f_equal</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">f_equal</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> !<span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>; <span class="id">apply</span> <span class="id">H</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHt</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">rewrite</span> !<span class="id">map_map</span>; <span class="id">apply</span> <span class="id">map_ext_in</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>; <span class="id">f_equal</span>; <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substf_exchange</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span> <span class="id">v</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">x</span> &lt;&gt; <span class="id">y</span> -&gt; <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">v</span> \/ <span class="id">y</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">u</span> -&gt; <span class="id">t</span> [ <span class="id">x</span> := <span class="id">u</span> ] [ <span class="id">y</span> := <span class="id">v</span> [ <span class="id">x</span> := <span class="id">u</span> ] ] = <span class="id">t</span> [ <span class="id">y</span> := <span class="id">v</span> ] [ <span class="id">x</span> := <span class="id">u</span> [ <span class="id">y</span> := <span class="id">v</span> ] ].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">u</span> <span class="id">v</span> <span class="id">x</span> <span class="id">y</span> <span class="id">Hxy</span> [<span class="id">Hx</span> | <span class="id">Hy</span>].<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> <span class="id">substf_fv</span> <span class="kwd">with</span> (<span class="id">x</span> := <span class="id">x</span>) (<span class="id">t</span> := <span class="id">v</span>) <span class="kwd">by</span> <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substf_substf</span> <span class="kwd">with</span> (<span class="id">u1</span> := <span class="id">u</span>) <span class="kwd">by</span> <span class="id">assumption</span>. <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> <span class="id">substf_fv</span> <span class="kwd">with</span> (<span class="id">x</span> := <span class="id">y</span>) (<span class="id">t</span> := <span class="id">u</span>) <span class="kwd">by</span> <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substf_substf</span> <span class="kwd">with</span> (<span class="id">u1</span> := <span class="id">v</span>) <span class="kwd">by</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">reflexivity</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeb_fv_eq</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">k</span> <span class="id">t</span>, <span class="id">fv</span> (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span>) == <span class="id">list_remove</span> <span class="id">x</span> (<span class="id">fv</span> <span class="id">t</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">x</span> <span class="id">k</span> <span class="id">t</span> <span class="id">y</span>. <span class="id">rewrite</span> <span class="id">list_remove_correct</span>. <span class="id">revert</span> <span class="id">k</span>; <span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>; <span class="id">intros</span> <span class="id">k</span>; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;- <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">intuition</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> <span class="id">IHt</span>. <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> !<span class="id">in_app_iff</span>, <span class="id">IHt1</span>, <span class="id">IHt2</span>. <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> <span class="id">map_map</span>, !<span class="id">concat_map_In</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> (<span class="id">t</span> &amp; <span class="id">Hy</span> &amp; <span class="id">Ht</span>); <span class="id">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">Hy</span> <span class="kwd">by</span> <span class="id">assumption</span>; <span class="id">split</span>; [<span class="kwd">exists</span> <span class="id">t</span>|]; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> [(<span class="id">t</span> &amp; <span class="id">Hy</span> &amp; <span class="id">Ht</span>) <span class="id">Hxy</span>]; <span class="kwd">exists</span> <span class="id">t</span>; <span class="id">rewrite</span> <span class="id">H</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> !<span class="id">in_app_iff</span>, <span class="id">map_map</span>, !<span class="id">concat_map_In</span>, <span class="id">IHt</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> [<span class="id">Hy</span> | ([<span class="id">p</span> <span class="id">t2</span>] &amp; <span class="id">Hy</span> &amp; <span class="id">Hpt2</span>)]; [<span class="id">tauto</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>) <span class="id">Hpt2</span>); <span class="id">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">Hy</span>. <span class="id">split</span>; [|<span class="id">tauto</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>; <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> [[<span class="id">Hy</span> | ([<span class="id">p</span> <span class="id">t2</span>] &amp; <span class="id">Hy</span> &amp; <span class="id">Hpt2</span>)] <span class="id">Hxy</span>]; [<span class="id">tauto</span>|]. <span class="id">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>) <span class="id">Hpt2</span>); <span class="id">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">rewrite</span> <span class="id">H</span>. <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">fv_closeb</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">x</span>, <span class="id">fv</span> (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span>) \<span class="id">subseteq</span> <span class="id">fv</span> <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span>. <span class="id">rewrite</span> <span class="id">closeb_fv_eq</span>. <span class="id">intros</span> <span class="id">y</span> <span class="id">Hy</span>; <span class="id">rewrite</span> <span class="id">list_remove_correct</span> <span class="kwd">in</span> <span class="id">Hy</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeb_var_free</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">k</span> <span class="id">t</span>, <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span>. <span class="id">rewrite</span> <span class="id">closeb_fv_eq</span>. <span class="id">rewrite</span> <span class="id">list_remove_correct</span>. <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">lc_at</span> : <span class="id">term</span> -&gt; <span class="id">nat</span> -&gt; <span class="kwd">Prop</span> :=<br/>
| <span class="id">lc_at_fvar</span> : <span class="kwd">forall</span> <span class="id">x</span> <span class="id">k</span>, <span class="id">lc_at</span> (<span class="id">fvar</span> <span class="id">x</span>) <span class="id">k</span><br/>
| <span class="id">lc_at_bvar</span> : <span class="kwd">forall</span> <span class="id">n</span> <span class="id">k</span>, <span class="id">n</span> &lt; <span class="id">k</span> -&gt; <span class="id">lc_at</span> (<span class="id">bvar</span> <span class="id">n</span>) <span class="id">k</span><br/>
| <span class="id">lc_at_lam</span> : <span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span>, <span class="id">lc_at</span> <span class="id">t</span> (<span class="id">S</span> <span class="id">k</span>) -&gt; <span class="id">lc_at</span> (<span class="id">lam</span> <span class="id">t</span>) <span class="id">k</span><br/>
| <span class="id">lc_at_app</span> : <span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span> <span class="id">k</span>, <span class="id">lc_at</span> <span class="id">t1</span> <span class="id">k</span> -&gt; <span class="id">lc_at</span> <span class="id">t2</span> <span class="id">k</span> -&gt; <span class="id">lc_at</span> (<span class="id">app</span> <span class="id">t1</span> <span class="id">t2</span>) <span class="id">k</span><br/>
| <span class="id">lc_at_constr</span> : <span class="kwd">forall</span> <span class="id">p</span> <span class="id">l</span> <span class="id">k</span>, (<span class="kwd">forall</span> <span class="id">t</span>, <span class="id">t</span> \<span class="kwd">in</span> <span class="id">l</span> -&gt; <span class="id">lc_at</span> <span class="id">t</span> <span class="id">k</span>) -&gt; <span class="id">lc_at</span> (<span class="id">constr</span> <span class="id">p</span> <span class="id">l</span>) <span class="id">k</span><br/>
| <span class="id">lc_at_switch</span> : <span class="kwd">forall</span> <span class="id">t</span> <span class="id">m</span> <span class="id">k</span>, <span class="id">lc_at</span> <span class="id">t</span> <span class="id">k</span> -&gt; (<span class="kwd">forall</span> <span class="id">p</span> <span class="id">t2</span>, (<span class="id">p</span>, <span class="id">t2</span>) \<span class="kwd">in</span> <span class="id">m</span> -&gt; <span class="id">lc_at</span> <span class="id">t2</span> (<span class="id">p</span> + <span class="id">k</span>)) -&gt; <span class="id">lc_at</span> (<span class="id">switch</span> <span class="id">t</span> <span class="id">m</span>) <span class="id">k</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">lc_at_substb_id</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k1</span> <span class="id">k2</span> <span class="id">u</span>, <span class="id">lc_at</span> <span class="id">t</span> <span class="id">k1</span> -&gt; <span class="id">k1</span> &lt;= <span class="id">k2</span> -&gt; <span class="id">t</span> [ <span class="id">k2</span> &lt;- <span class="id">u</span> ] = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>; <span class="id">intros</span> <span class="id">k1</span> <span class="id">k2</span> <span class="id">u</span> <span class="id">H1</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">H1</span>; <span class="id">subst</span>. <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>; [<span class="id">lia</span>|<span class="id">reflexivity</span>].<br/>
&nbsp;&nbsp;- <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">f_equal</span>. <span class="id">inversion</span> <span class="id">H1</span>; <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">IHt</span>; [<span class="id">eassumption</span>|]. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">H1</span>; <span class="id">subst</span>. <span class="id">f_equal</span>; <span class="id">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">f_equal</span>. <span class="id">erewrite</span> <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>. <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inversion</span> <span class="id">H1</span>; <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">eapply</span> <span class="id">H</span>; [<span class="id">eassumption</span>|<span class="id">apply</span> <span class="id">H5</span>; <span class="id">assumption</span>|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">H1</span>; <span class="id">subst</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">eapply</span> <span class="id">IHt</span>; <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">erewrite</span> <span class="id">map_ext_in</span>; [<span class="id">apply</span> <span class="id">map_id</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>. <span class="id">f_equal</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>) <span class="id">Hpt2</span>); [<span class="id">eapply</span> <span class="id">H6</span>; <span class="id">eassumption</span>|]. <span class="id">lia</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">lc_at_inc</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k1</span> <span class="id">k2</span>, <span class="id">lc_at</span> <span class="id">t</span> <span class="id">k1</span> -&gt; <span class="id">k1</span> &lt;= <span class="id">k2</span> -&gt; <span class="id">lc_at</span> <span class="id">t</span> <span class="id">k2</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">k1</span> <span class="id">k2</span> <span class="id">H</span>; <span class="id">revert</span> <span class="id">k2</span>; <span class="id">induction</span> <span class="id">H</span>; <span class="id">intros</span> <span class="id">k2</span> <span class="id">Hk</span>.<br/>
&nbsp;&nbsp;- <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;- <span class="id">constructor</span>; <span class="id">lia</span>.<br/>
&nbsp;&nbsp;- <span class="id">constructor</span>. <span class="id">apply</span> <span class="id">IHlc_at</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;- <span class="id">constructor</span>; [<span class="id">apply</span> <span class="id">IHlc_at1</span>|<span class="id">apply</span> <span class="id">IHlc_at2</span>]; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">constructor</span>. <span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>; <span class="id">apply</span> <span class="id">H0</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">constructor</span>; [<span class="id">apply</span> <span class="id">IHlc_at</span>; <span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">p</span> <span class="id">t2</span> <span class="id">Hpt2</span>; <span class="id">eapply</span> <span class="id">H1</span>; [<span class="id">eassumption</span>|]; <span class="id">lia</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">lc_at_substb_lc_at</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">u</span>, <span class="id">lc_at</span> <span class="id">u</span> 0 -&gt; <span class="id">lc_at</span> <span class="id">t</span> (<span class="id">S</span> <span class="id">k</span>) -&gt; <span class="id">lc_at</span> (<span class="id">t</span> [ <span class="id">k</span> &lt;- <span class="id">u</span> ]) <span class="id">k</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>; <span class="id">intros</span> <span class="id">k</span> <span class="id">u</span> <span class="id">H1</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">eapply</span> <span class="id">lc_at_inc</span>; [<span class="id">eassumption</span>|<span class="id">lia</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inversion</span> <span class="id">H2</span>. <span class="id">constructor</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>; <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">H2</span>; <span class="id">subst</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">IHt</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">H2</span>; <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>; [<span class="id">apply</span> <span class="id">IHt1</span> | <span class="id">apply</span> <span class="id">IHt2</span>]; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t2</span> <span class="id">Ht2</span>; <span class="id">rewrite</span> <span class="id">in_map_iff</span> <span class="kwd">in</span> <span class="id">Ht2</span>; <span class="id">destruct</span> <span class="id">Ht2</span> <span class="kwd">as</span> (<span class="id">t</span> &amp; &lt;- &amp; <span class="id">Ht</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inversion</span> <span class="id">H2</span>; <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">apply</span> <span class="id">H</span>; [<span class="id">assumption</span>|<span class="id">assumption</span>|<span class="id">apply</span> <span class="id">H5</span>; <span class="id">assumption</span>].<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">H2</span>; <span class="id">subst</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHt</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> <span class="id">p2</span> <span class="id">t3</span> <span class="id">Hpt3</span>; <span class="id">rewrite</span> <span class="id">in_map_iff</span> <span class="kwd">in</span> <span class="id">Hpt3</span>; <span class="id">destruct</span> <span class="id">Hpt3</span> <span class="kwd">as</span> ([<span class="id">p</span> <span class="id">t2</span>] &amp; [= &lt;- &lt;-] &amp; <span class="id">Hpt2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); <span class="id">try</span> <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">replace</span> (<span class="id">S</span> (<span class="id">p</span> + <span class="id">k</span>)) <span class="kwd">with</span> (<span class="id">p</span> + <span class="id">S</span> <span class="id">k</span>) <span class="kwd">by</span> <span class="id">lia</span>. <span class="id">apply</span> <span class="id">H6</span>; <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">lc_at_substb_list_lc_at</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">us</span>, (<span class="kwd">forall</span> <span class="id">u</span>, <span class="id">In</span> <span class="id">u</span> <span class="id">us</span> -&gt; <span class="id">lc_at</span> <span class="id">u</span> 0) -&gt; <span class="id">lc_at</span> <span class="id">t</span> (<span class="id">length</span> <span class="id">us</span> + <span class="id">k</span>) -&gt; <span class="id">lc_at</span> (<span class="id">substb_list</span> <span class="id">k</span> <span class="id">us</span> <span class="id">t</span>) <span class="id">k</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">k</span> <span class="id">us</span>. <span class="id">revert</span> <span class="id">t</span> <span class="id">k</span>; <span class="id">induction</span> <span class="id">us</span> <span class="kwd">as</span> [|<span class="id">u</span> <span class="id">us</span>]; <span class="id">intros</span> <span class="id">t</span> <span class="id">k</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">apply</span> <span class="id">lc_at_substb_lc_at</span>; [<span class="id">apply</span> <span class="id">H</span>; <span class="id">tauto</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">IHus</span>; [<span class="id">intros</span> <span class="id">u1</span> <span class="id">Hu1</span>; <span class="id">apply</span> <span class="id">H</span>; <span class="id">tauto</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">replace</span> (<span class="id">length</span> <span class="id">us</span> + <span class="id">S</span> <span class="id">k</span>) <span class="kwd">with</span> (<span class="id">S</span> (<span class="id">length</span> <span class="id">us</span> + <span class="id">k</span>)) <span class="kwd">by</span> <span class="id">lia</span>; <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">lc_at_substb_lc_at2</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">u</span>, <span class="id">lc_at</span> (<span class="id">t</span> [ <span class="id">k</span> &lt;- <span class="id">u</span> ]) <span class="id">k</span> -&gt; <span class="id">lc_at</span> <span class="id">t</span> (<span class="id">S</span> <span class="id">k</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>; <span class="id">intros</span> <span class="id">k</span> <span class="id">u</span> <span class="id">Hlc</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">constructor</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inversion</span> <span class="id">Hlc</span>. <span class="id">constructor</span>. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>; <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">Hlc</span>; <span class="id">subst</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">IHt</span>; <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">Hlc</span>; <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>; [<span class="id">eapply</span> <span class="id">IHt1</span> | <span class="id">eapply</span> <span class="id">IHt2</span>]; <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">inversion</span> <span class="id">Hlc</span>; <span class="id">subst</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>. <span class="id">eapply</span> <span class="id">H</span>; [<span class="id">eassumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">H3</span>. <span class="id">apply</span> <span class="id">in_map</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">inversion</span> <span class="id">Hlc</span>; <span class="id">subst</span>. <span class="id">constructor</span>; [<span class="id">eapply</span> <span class="id">IHt</span>; <span class="id">eassumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">p</span> <span class="id">t2</span> <span class="id">Hpt2</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">specialize</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>) <span class="id">Hpt2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">replace</span> (<span class="id">p</span> + <span class="id">S</span> <span class="id">k</span>) <span class="kwd">with</span> (<span class="id">S</span> (<span class="id">p</span> + <span class="id">k</span>)) <span class="kwd">by</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">H</span>. <span class="id">apply</span> <span class="id">H4</span>. <span class="id">rewrite</span> <span class="id">in_map_iff</span>; <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">split</span>; [<span class="id">reflexivity</span>|<span class="id">assumption</span>].<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">lc_at_substb_list_lc_at2</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">us</span>, <span class="id">lc_at</span> (<span class="id">substb_list</span> <span class="id">k</span> <span class="id">us</span> <span class="id">t</span>) <span class="id">k</span> -&gt; <span class="id">lc_at</span> <span class="id">t</span> (<span class="id">length</span> <span class="id">us</span> + <span class="id">k</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">k</span> <span class="id">us</span>. <span class="id">revert</span> <span class="id">t</span> <span class="id">k</span>; <span class="id">induction</span> <span class="id">us</span> <span class="kwd">as</span> [|<span class="id">u</span> <span class="id">us</span>]; <span class="id">intros</span> <span class="id">t</span> <span class="id">k</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">replace</span> (<span class="id">S</span> (<span class="id">length</span> <span class="id">us</span> + <span class="id">k</span>)) <span class="kwd">with</span> (<span class="id">length</span> <span class="id">us</span> + <span class="id">S</span> <span class="id">k</span>) <span class="kwd">by</span> <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">IHus</span>. <span class="id">eapply</span> <span class="id">lc_at_substb_lc_at2</span>. <span class="id">eassumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">size</span> <span class="id">t</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">t</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">bvar</span> <span class="id">_</span> =&gt; 0<br/>
&nbsp;&nbsp;| <span class="id">fvar</span> <span class="id">_</span> =&gt; 0<br/>
&nbsp;&nbsp;| <span class="id">lam</span> <span class="id">t</span> =&gt; <span class="id">S</span> (<span class="id">size</span> <span class="id">t</span>)<br/>
&nbsp;&nbsp;| <span class="id">app</span> <span class="id">t1</span> <span class="id">t2</span> =&gt; <span class="id">S</span> (<span class="id">Nat.max</span> (<span class="id">size</span> <span class="id">t1</span>) (<span class="id">size</span> <span class="id">t2</span>))<br/>
&nbsp;&nbsp;| <span class="id">constr</span> <span class="id">p</span> <span class="id">l</span> =&gt; <span class="id">smallest_above</span> (<span class="id">map</span> <span class="id">size</span> <span class="id">l</span>)<br/>
&nbsp;&nbsp;| <span class="id">switch</span> <span class="id">t</span> <span class="id">m</span> =&gt; <span class="id">Nat.max</span> (<span class="id">S</span> (<span class="id">size</span> <span class="id">t</span>)) (<span class="id">smallest_above</span> (<span class="id">map</span> (<span class="kwd">fun</span> <span class="id">pt2</span> =&gt; <span class="id">size</span> (<span class="id">snd</span> <span class="id">pt2</span>)) <span class="id">m</span>))<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_size</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">x</span>, <span class="id">size</span> (<span class="id">t</span> [ <span class="id">k</span> &lt;- <span class="id">fvar</span> <span class="id">x</span> ]) = <span class="id">size</span> <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>; <span class="id">intros</span> <span class="id">k</span> <span class="id">x</span>; <span class="id">unfold</span> <span class="id">size</span>, <span class="id">substb</span>; <span class="id">fold</span> <span class="id">size</span>; <span class="id">fold</span> <span class="id">substb</span>.<br/>
&nbsp;&nbsp;- <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>; <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> <span class="id">IHt</span>; <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> <span class="id">IHt1</span>, <span class="id">IHt2</span>; <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> <span class="id">map_map</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">map_ext_in</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>; <span class="id">apply</span> <span class="id">H</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> <span class="id">IHt</span>. <span class="id">f_equal</span>. <span class="id">rewrite</span> <span class="id">map_map</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">map_ext_in</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>; <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_list_size</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">xs</span>, <span class="id">size</span> (<span class="id">substb_list</span> <span class="id">k</span> (<span class="id">map</span> <span class="id">fvar</span> <span class="id">xs</span>) <span class="id">t</span>) = <span class="id">size</span> <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">k</span> <span class="id">xs</span>; <span class="id">revert</span> <span class="id">t</span> <span class="id">k</span>; <span class="id">induction</span> <span class="id">xs</span> <span class="kwd">as</span> [|<span class="id">x</span> <span class="id">xs</span>]; <span class="id">intros</span> <span class="id">t</span> <span class="id">k</span>.<br/>
&nbsp;&nbsp;- <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">open_size</span>. <span class="id">apply</span> <span class="id">IHxs</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">lc_at_lc</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span>, <span class="id">lc</span> <span class="id">t</span> &lt;-&gt; <span class="id">lc_at</span> <span class="id">t</span> 0.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span>. <span class="id">split</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">H</span>. <span class="id">induction</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">constructor</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">constructor</span>. <span class="id">pick</span> <span class="id">x</span> \<span class="id">notin</span> <span class="id">L</span> <span class="kwd">as</span> <span class="id">Hx</span>. <span class="id">eapply</span> <span class="id">lc_at_substb_lc_at2</span>. <span class="id">apply</span> <span class="id">H0</span>; <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">constructor</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">constructor</span>; [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">p</span> <span class="id">t2</span> <span class="id">Hpt2</span>. <span class="id">pickn</span> <span class="id">p</span> <span class="id">distinct</span> <span class="id">xs</span> \<span class="id">notin</span> <span class="id">L</span> <span class="kwd">as</span> <span class="id">Hxs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H1</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Hpt2</span> <span class="id">Hxs</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">lc_at_substb_list_lc_at2</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">rewrite</span> <span class="id">map_length</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">distinct_length</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">remember</span> (<span class="id">size</span> <span class="id">t</span>) <span class="kwd">as</span> <span class="id">n</span>. <span class="id">revert</span> <span class="id">t</span> <span class="id">Heqn</span>. <span class="id">refine</span> (<span class="id">lt_wf_ind</span> <span class="id">n</span> (<span class="kwd">fun</span> <span class="id">n</span> =&gt; <span class="id">_</span>) <span class="id">_</span>). <span class="id">clear</span> <span class="id">n</span>. <span class="id">intros</span> <span class="id">n</span> <span class="id">Hrec</span> <span class="id">t</span> <span class="id">Hsize</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">t</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">inversion</span> <span class="id">H</span>; <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">simpl</span> <span class="kwd">in</span> <span class="id">Hsize</span>. <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inversion</span> <span class="id">H</span>; <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">lc_lam</span> <span class="kwd">with</span> (<span class="id">L</span> := <span class="id">nil</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">x</span> <span class="id">_</span>. <span class="id">eapply</span> <span class="id">Hrec</span>; [|<span class="id">reflexivity</span>|]; [<span class="id">rewrite</span> <span class="id">open_size</span>; <span class="id">lia</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">lc_at_substb_lc_at</span>; [<span class="id">constructor</span>|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">simpl</span> <span class="kwd">in</span> <span class="id">Hsize</span>. <span class="id">subst</span>. <span class="id">inversion</span> <span class="id">H</span>; <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">all</span>: <span class="id">eapply</span> <span class="id">Hrec</span>; [|<span class="id">reflexivity</span>|]; [<span class="id">lia</span>|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">simpl</span> <span class="kwd">in</span> <span class="id">Hsize</span>. <span class="id">subst</span>. <span class="id">inversion</span> <span class="id">H</span>; <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>. <span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>. <span class="id">eapply</span> <span class="id">Hrec</span>; [|<span class="id">reflexivity</span>|<span class="id">apply</span> <span class="id">H3</span>; <span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">smallest_above_map_gt</span>. <span class="kwd">exists</span> <span class="id">t</span>. <span class="id">split</span>; [<span class="id">reflexivity</span>|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">unfold</span> <span class="id">size</span> <span class="kwd">in</span> <span class="id">Hsize</span>. <span class="id">fold</span> <span class="id">size</span> <span class="kwd">in</span> <span class="id">Hsize</span>. <span class="id">subst</span>. <span class="id">inversion</span> <span class="id">H</span>; <span class="id">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">lc_switch</span> <span class="kwd">with</span> (<span class="id">L</span> := <span class="id">nil</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">eapply</span> <span class="id">Hrec</span>; [|<span class="id">reflexivity</span>|<span class="id">assumption</span>]. <span class="id">lia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">intros</span> <span class="id">p</span> <span class="id">t2</span> <span class="id">xs</span> <span class="id">Hpt2</span> <span class="id">Hxs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">Hrec</span>; [|<span class="id">reflexivity</span>|]; [<span class="id">rewrite</span> <span class="id">open_list_size</span>, <span class="id">Nat.max_lt_iff</span>; <span class="id">right</span>; <span class="id">apply</span> <span class="id">smallest_above_map_gt</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">simpl</span>; <span class="id">split</span>; [<span class="id">reflexivity</span>|<span class="id">assumption</span>]|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">lc_at_substb_list_lc_at</span>; [|<span class="id">erewrite</span> <span class="id">map_length</span>, <span class="id">distinct_length</span>; [|<span class="id">eassumption</span>]; <span class="id">apply</span> <span class="id">H4</span>; <span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">u</span> <span class="id">Hu</span>; <span class="id">rewrite</span> <span class="id">in_map_iff</span> <span class="kwd">in</span> <span class="id">Hu</span>; <span class="id">destruct</span> <span class="id">Hu</span> <span class="kwd">as</span> (<span class="id">x</span> &amp; &lt;- &amp; <span class="id">Hx</span>). <span class="id">constructor</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substf_lc2</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">x</span> <span class="id">u</span>, <span class="id">lc</span> (<span class="id">t</span> [ <span class="id">x</span> := <span class="id">u</span> ]) -&gt; <span class="id">lc</span> <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span>. <span class="id">rewrite</span> <span class="id">lc_at_lc</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">remember</span> 0 <span class="kwd">as</span> <span class="id">k</span>. <span class="id">clear</span> <span class="id">Heqk</span>.<br/>
&nbsp;&nbsp;<span class="id">revert</span> <span class="id">k</span> <span class="id">H</span>. <span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>; <span class="id">intros</span> <span class="id">k</span> <span class="id">Hlc</span>; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;- <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;- <span class="id">constructor</span>. <span class="id">apply</span> <span class="id">IHt</span>. <span class="id">inversion</span> <span class="id">Hlc</span>; <span class="id">subst</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">inversion</span> <span class="id">Hlc</span>; <span class="id">subst</span>. <span class="id">constructor</span>; [<span class="id">apply</span> <span class="id">IHt1</span> | <span class="id">apply</span> <span class="id">IHt2</span>]; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">inversion</span> <span class="id">Hlc</span>; <span class="id">subst</span>. <span class="id">constructor</span>. <span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">apply</span> <span class="id">H</span>; [<span class="id">assumption</span>|]. <span class="id">apply</span> <span class="id">H3</span>, <span class="id">in_map</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">inversion</span> <span class="id">Hlc</span>; <span class="id">subst</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHt</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> <span class="id">p</span> <span class="id">t2</span> <span class="id">Hpt2</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">H4</span>. <span class="id">rewrite</span> <span class="id">in_map_iff</span>; <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">simpl</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_list_lc</span> : <span class="kwd">forall</span> <span class="id">us</span> <span class="id">t</span>, <span class="id">bodies</span> (<span class="id">length</span> <span class="id">us</span>) <span class="id">t</span> -&gt; (<span class="kwd">forall</span> <span class="id">u</span>, <span class="id">u</span> \<span class="kwd">in</span> <span class="id">us</span> -&gt; <span class="id">lc</span> <span class="id">u</span>) -&gt; <span class="id">lc</span> (<span class="id">substb_list</span> 0 <span class="id">us</span> <span class="id">t</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">us</span> <span class="id">t</span> <span class="id">Hbodies</span> <span class="id">Hlc</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">lc_at_lc</span>. <span class="id">apply</span> <span class="id">lc_at_substb_list_lc_at</span>; [<span class="id">intros</span> <span class="id">u</span> <span class="id">Hu</span>; <span class="id">rewrite</span> &lt;- <span class="id">lc_at_lc</span>; <span class="id">apply</span> <span class="id">Hlc</span>; <span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">Hbodies</span> <span class="kwd">as</span> [<span class="id">L</span> <span class="id">Ht</span>]. <span class="id">pickn</span> (<span class="id">length</span> <span class="id">us</span>) <span class="id">distinct</span> <span class="id">xs</span> \<span class="id">notin</span> <span class="id">L</span> <span class="kwd">as</span> <span class="id">Hxs</span>. <span class="id">specialize</span> (<span class="id">Ht</span> <span class="id">xs</span> <span class="id">Hxs</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">lc_at_lc</span> <span class="kwd">in</span> <span class="id">Ht</span>. <span class="id">apply</span> <span class="id">lc_at_substb_list_lc_at2</span> <span class="kwd">in</span> <span class="id">Ht</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">map_length</span>, <span class="id">distinct_length</span> <span class="kwd">in</span> <span class="id">Ht</span>; <span class="id">eassumption</span>.<br/>
Qed.</details>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">body_substf</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">u</span> <span class="id">x</span>, <span class="id">lc</span> <span class="id">u</span> -&gt; <span class="id">body</span> (<span class="id">t</span> [<span class="id">x</span> := <span class="id">u</span>]) &lt;-&gt; <span class="id">body</span> <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span>. <span class="id">split</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> [<span class="id">L</span> <span class="id">HL</span>]. <span class="kwd">exists</span> (<span class="id">x</span> :: <span class="id">L</span>). <span class="id">intros</span> <span class="id">y</span> <span class="id">Hy</span>. <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">specialize</span> (<span class="id">HL</span> <span class="id">y</span> <span class="id">ltac</span>:(<span class="id">tauto</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substf_substb_free</span> <span class="kwd">in</span> <span class="id">HL</span> <span class="kwd">by</span> (<span class="id">simpl</span>; <span class="id">intuition</span> <span class="id">congruence</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">substf_lc2</span>; <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> [<span class="id">L</span> <span class="id">HL</span>]. <span class="kwd">exists</span> (<span class="id">x</span> :: <span class="id">L</span>). <span class="id">intros</span> <span class="id">y</span> <span class="id">Hy</span>. <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">specialize</span> (<span class="id">HL</span> <span class="id">y</span> <span class="id">ltac</span>:(<span class="id">tauto</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substf_substb_free</span> <span class="kwd">by</span> (<span class="id">simpl</span>; <span class="id">intuition</span> <span class="id">congruence</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">substf_lc</span>; <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">bodies_lc_at</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">t</span>, <span class="id">bodies</span> <span class="id">n</span> <span class="id">t</span> &lt;-&gt; <span class="id">lc_at</span> <span class="id">t</span> <span class="id">n</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">n</span> <span class="id">t</span>. <span class="id">split</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> [<span class="id">L</span> <span class="id">HL</span>]. <span class="id">pickn</span> <span class="id">n</span> <span class="id">distinct</span> <span class="id">xs</span> \<span class="id">notin</span> <span class="id">L</span> <span class="kwd">as</span> <span class="id">Hxs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">HL</span> <span class="id">xs</span> <span class="id">Hxs</span>). <span class="id">rewrite</span> <span class="id">lc_at_lc</span> <span class="kwd">in</span> <span class="id">HL</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">lc_at_substb_list_lc_at2</span> <span class="kwd">in</span> <span class="id">HL</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">map_length</span>, <span class="id">distinct_length</span>, <span class="id">plus_0_r</span> <span class="kwd">in</span> <span class="id">HL</span>; [|<span class="id">eassumption</span>]. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">H</span>. <span class="kwd">exists</span> <span class="id">nil</span>. <span class="id">intros</span> <span class="id">xs</span> <span class="id">Hxs</span>. <span class="id">rewrite</span> <span class="id">lc_at_lc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">lc_at_substb_list_lc_at</span>; [<span class="id">rewrite</span> <span class="id">forall_map</span>; <span class="id">intros</span>; <span class="id">constructor</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">map_length</span>, <span class="id">distinct_length</span>, <span class="id">plus_0_r</span>; <span class="id">eassumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">bodies_substf</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">t</span> <span class="id">u</span> <span class="id">x</span>, <span class="id">lc</span> <span class="id">u</span> -&gt; <span class="id">bodies</span> <span class="id">n</span> (<span class="id">t</span> [<span class="id">x</span> := <span class="id">u</span>]) &lt;-&gt; <span class="id">bodies</span> <span class="id">n</span> <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span>. <span class="id">split</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">Ht</span>. <span class="kwd">exists</span> (<span class="id">x</span> :: <span class="id">nil</span>). <span class="id">intros</span> <span class="id">ys</span> <span class="id">Hys</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">substf_lc2</span>. <span class="id">rewrite</span> &lt;- <span class="id">substf_substb_list_free</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">substb_list_lc</span>; [<span class="id">erewrite</span> <span class="id">map_length</span>, <span class="id">distinct_length</span>; <span class="id">eassumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">forall_map</span>; <span class="id">intros</span>; <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">rewrite</span> <span class="id">forall_map</span>. <span class="id">simpl</span>. <span class="id">intros</span> <span class="id">y</span> <span class="id">Hy</span> [-&gt;|[]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">distinct_distinct</span>; [<span class="id">eassumption</span>| |<span class="id">eassumption</span>]; <span class="id">simpl</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">Ht</span>. <span class="kwd">exists</span> (<span class="id">x</span> :: <span class="id">nil</span>). <span class="id">intros</span> <span class="id">ys</span> <span class="id">Hys</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substf_substb_list_free</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">substf_lc</span>; [|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> <span class="id">substb_list_lc</span>; [<span class="id">erewrite</span> <span class="id">map_length</span>, <span class="id">distinct_length</span>; <span class="id">eassumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">forall_map</span>. <span class="id">intros</span>; <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">rewrite</span> <span class="id">forall_map</span>. <span class="id">simpl</span>. <span class="id">intros</span> <span class="id">y</span> <span class="id">Hy</span> [-&gt;|[]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eapply</span> <span class="id">distinct_distinct</span>; [<span class="id">eassumption</span>| |<span class="id">eassumption</span>]; <span class="id">simpl</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_close_at</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">x</span> <span class="id">u</span>, <span class="id">lc_at</span> <span class="id">t</span> <span class="id">k</span> -&gt; <span class="id">lc</span> <span class="id">u</span> -&gt; <span class="id">substb</span> <span class="id">k</span> <span class="id">u</span> (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span>) = <span class="id">t</span> [<span class="id">x</span> := <span class="id">u</span>].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span>. <span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>; <span class="id">intros</span> <span class="id">k</span> <span class="id">x</span> <span class="id">u</span> <span class="id">Hlct</span> <span class="id">Hlcu</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">Hlct</span>; <span class="id">subst</span>. <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>; [<span class="id">lia</span> | <span class="id">reflexivity</span>].<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">simpl</span>; <span class="id">try</span> <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>; <span class="id">simpl</span>; <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">Hlct</span>; <span class="id">subst</span>. <span class="id">f_equal</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">Hlct</span>; <span class="id">subst</span>. <span class="id">f_equal</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">Hlct</span>; <span class="id">subst</span>. <span class="id">f_equal</span>. <span class="id">rewrite</span> <span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> <span class="id">H</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">inversion</span> <span class="id">Hlct</span>; <span class="id">subst</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHt</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">rewrite</span> <span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); <span class="id">auto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_close_var_at</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">x</span>, <span class="id">lc_at</span> <span class="id">t</span> <span class="id">k</span> -&gt; <span class="id">substb</span> <span class="id">k</span> (<span class="id">fvar</span> <span class="id">x</span>) (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span>) = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span>. <span class="id">rewrite</span> <span class="id">open_close_at</span>, <span class="id">substf_id</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_close_var_list_at</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">xs</span> <span class="id">k</span> <span class="id">t</span>, <span class="id">lc_at</span> <span class="id">t</span> <span class="id">k</span> -&gt; <span class="id">substb_list</span> <span class="id">k</span> (<span class="id">map</span> <span class="id">fvar</span> <span class="id">xs</span>) (<span class="id">closeb_list</span> <span class="id">k</span> <span class="id">xs</span> <span class="id">t</span>) = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">xs</span> <span class="kwd">as</span> [|<span class="id">x</span> <span class="id">xs</span>]; <span class="id">intros</span> <span class="id">k</span> <span class="id">t</span> <span class="id">Hlc</span>; [<span class="id">reflexivity</span>|].<br/>
&nbsp;&nbsp;<span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">IHxs</span>.<br/>
&nbsp;&nbsp;- <span class="id">apply</span> <span class="id">open_close_var_at</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">eapply</span> <span class="id">lc_at_substb_lc_at2</span>. <span class="id">rewrite</span> <span class="id">open_close_var_at</span>; <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_close_var_list</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">xs</span> <span class="id">k</span> <span class="id">t</span>, <span class="id">lc</span> <span class="id">t</span> -&gt; <span class="id">substb_list</span> <span class="id">k</span> (<span class="id">map</span> <span class="id">fvar</span> <span class="id">xs</span>) (<span class="id">closeb_list</span> <span class="id">k</span> <span class="id">xs</span> <span class="id">t</span>) = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span>. <span class="id">apply</span> <span class="id">open_close_var_list_at</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span> <span class="id">lc_at_lc</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">eapply</span> <span class="id">lc_at_inc</span>; [<span class="id">eassumption</span>|]. <span class="id">lia</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">substb_list_app</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">us1</span> <span class="id">us2</span> <span class="id">k</span> <span class="id">t</span>, <span class="id">substb_list</span> <span class="id">k</span> (<span class="id">us1</span> ++ <span class="id">us2</span>) <span class="id">t</span> = <span class="id">substb_list</span> <span class="id">k</span> <span class="id">us1</span> (<span class="id">substb_list</span> (<span class="id">length</span> <span class="id">us1</span> + <span class="id">k</span>) <span class="id">us2</span> <span class="id">t</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">us1</span> <span class="kwd">as</span> [|<span class="id">u</span> <span class="id">us1</span>].<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>; <span class="id">rewrite</span> <span class="id">IHus1</span>; <span class="id">f_equal</span>; <span class="id">f_equal</span>; <span class="id">f_equal</span>; <span class="id">lia</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeb_list_app</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">xs1</span> <span class="id">xs2</span> <span class="id">k</span> <span class="id">t</span>, <span class="id">closeb_list</span> <span class="id">k</span> (<span class="id">xs1</span> ++ <span class="id">xs2</span>) <span class="id">t</span> = <span class="id">closeb_list</span> (<span class="id">length</span> <span class="id">xs1</span> + <span class="id">k</span>) <span class="id">xs2</span> (<span class="id">closeb_list</span> <span class="id">k</span> <span class="id">xs1</span> <span class="id">t</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">xs1</span> <span class="kwd">as</span> [|<span class="id">x</span> <span class="id">xs1</span>].<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>; <span class="id">rewrite</span> <span class="id">IHxs1</span>; <span class="id">f_equal</span>; <span class="id">lia</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeb_list_substf</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ys</span> <span class="id">k</span> <span class="id">t</span> <span class="id">x</span> <span class="id">u</span>, (<span class="kwd">forall</span> <span class="id">y</span>, <span class="id">y</span> \<span class="kwd">in</span> <span class="id">ys</span> -&gt; <span class="id">y</span> \<span class="id">notin</span> (<span class="id">x</span> :: <span class="id">fv</span> <span class="id">u</span>)) -&gt; <span class="id">closeb_list</span> <span class="id">k</span> <span class="id">ys</span> (<span class="id">t</span> [<span class="id">x</span> := <span class="id">u</span>]) = <span class="id">closeb_list</span> <span class="id">k</span> <span class="id">ys</span> <span class="id">t</span> [<span class="id">x</span> := <span class="id">u</span>].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">ys</span> <span class="kwd">as</span> [|<span class="id">y</span> <span class="id">ys</span>]; <span class="id">intros</span> <span class="id">k</span> <span class="id">t</span> <span class="id">x</span> <span class="id">u</span> <span class="id">Hys</span>.<br/>
&nbsp;&nbsp;- <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">rewrite</span> &lt;- <span class="id">IHys</span> <span class="kwd">by</span> (<span class="id">intros</span>; <span class="id">apply</span> <span class="id">Hys</span>; <span class="id">simpl</span>; <span class="id">tauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f_equal</span>. <span class="id">rewrite</span> <span class="id">closeb_substf_free</span>; [<span class="id">reflexivity</span>| |].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> -&gt;. <span class="id">eapply</span> <span class="id">Hys</span>; <span class="id">simpl</span>; <span class="id">left</span>; <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">intros</span> <span class="id">H</span>. <span class="id">eapply</span> <span class="id">Hys</span>; [<span class="id">simpl</span>; <span class="id">left</span>; <span class="id">reflexivity</span>|]. <span class="id">simpl</span>. <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">distinct_swap</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">L</span> <span class="id">p</span> <span class="id">x1</span> <span class="id">x2</span> <span class="id">xs</span>, <span class="id">distinct</span> <span class="id">L</span> <span class="id">p</span> (<span class="id">x1</span> :: <span class="id">x2</span> :: <span class="id">xs</span>) &lt;-&gt; <span class="id">distinct</span> <span class="id">L</span> <span class="id">p</span> (<span class="id">x2</span> :: <span class="id">x1</span> :: <span class="id">xs</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span>; <span class="id">revert</span> <span class="id">x1</span> <span class="id">x2</span>.<br/>
&nbsp;&nbsp;<span class="id">enough</span> (<span class="id">H</span> : <span class="kwd">forall</span> <span class="id">x1</span> <span class="id">x2</span>, <span class="id">distinct</span> <span class="id">L</span> <span class="id">p</span> (<span class="id">x1</span> :: <span class="id">x2</span> :: <span class="id">xs</span>) -&gt; <span class="id">distinct</span> <span class="id">L</span> <span class="id">p</span> (<span class="id">x2</span> :: <span class="id">x1</span> :: <span class="id">xs</span>)) <span class="kwd">by</span> (<span class="id">intros</span>; <span class="id">split</span>; <span class="id">apply</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">x1</span> <span class="id">x2</span> <span class="id">Hdistinct</span>. <span class="id">inversion</span> <span class="id">Hdistinct</span>; <span class="id">subst</span>.<br/>
&nbsp;&nbsp;<span class="id">inversion</span> <span class="id">H4</span>; <span class="id">subst</span>. <span class="id">constructor</span>; [|<span class="id">constructor</span>].<br/>
&nbsp;&nbsp;- <span class="id">intros</span> <span class="id">Hx2</span>; <span class="id">apply</span> <span class="id">H5</span>; <span class="id">simpl</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span> [-&gt; | <span class="id">H</span>]; [|<span class="id">apply</span> <span class="id">H3</span>; <span class="id">assumption</span>]. <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">eapply</span> <span class="id">distinct_incl</span>; [|<span class="id">eassumption</span>]. <span class="id">prove_list_inc</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">distinct_app_cons</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">L</span> <span class="id">p</span> <span class="id">x</span> <span class="id">xs1</span> <span class="id">xs2</span>, <span class="id">distinct</span> <span class="id">L</span> <span class="id">p</span> (<span class="id">x</span> :: <span class="id">xs1</span> ++ <span class="id">xs2</span>) &lt;-&gt; <span class="id">distinct</span> <span class="id">L</span> <span class="id">p</span> (<span class="id">xs1</span> ++ <span class="id">x</span> :: <span class="id">xs2</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">L</span> <span class="id">p</span> <span class="id">x</span> <span class="id">xs1</span>; <span class="id">revert</span> <span class="id">L</span> <span class="id">p</span> <span class="id">x</span>; <span class="id">induction</span> <span class="id">xs1</span> <span class="kwd">as</span> [|<span class="id">y</span> <span class="id">xs1</span>]; <span class="id">intros</span> <span class="id">L</span> <span class="id">p</span> <span class="id">x</span> <span class="id">xs2</span>; [<span class="id">reflexivity</span>|].<br/>
&nbsp;&nbsp;<span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">distinct_swap</span>.<br/>
&nbsp;&nbsp;<span class="id">split</span>; <span class="id">intros</span> <span class="id">H</span>; <span class="id">inversion</span> <span class="id">H</span>; <span class="id">subst</span>; <span class="id">constructor</span>; <span class="id">try</span> <span class="id">assumption</span>; <span class="id">rewrite</span> <span class="id">IHxs1</span> <span class="kwd">in</span> *; <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">distinct_app</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">L</span> <span class="id">p</span> <span class="id">xs1</span> <span class="id">xs2</span>, <span class="id">distinct</span> <span class="id">L</span> <span class="id">p</span> (<span class="id">xs1</span> ++ <span class="id">xs2</span>) &lt;-&gt; <span class="id">distinct</span> <span class="id">L</span> <span class="id">p</span> (<span class="id">xs2</span> ++ <span class="id">xs1</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">L</span> <span class="id">p</span>.<br/>
&nbsp;&nbsp;<span class="id">enough</span> (<span class="id">H</span> : <span class="kwd">forall</span> <span class="id">xs1</span> <span class="id">xs2</span>, <span class="id">distinct</span> <span class="id">L</span> <span class="id">p</span> (<span class="id">xs1</span> ++ <span class="id">xs2</span>) -&gt; <span class="id">distinct</span> <span class="id">L</span> <span class="id">p</span> (<span class="id">xs2</span> ++ <span class="id">xs1</span>)) <span class="kwd">by</span> (<span class="id">intros</span>; <span class="id">split</span>; <span class="id">apply</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">xs1</span>; <span class="id">revert</span> <span class="id">L</span> <span class="id">p</span>; <span class="id">induction</span> <span class="id">xs1</span> <span class="kwd">as</span> [|<span class="id">x</span> <span class="id">xs1</span>]; <span class="id">intros</span> <span class="id">L</span> <span class="id">p</span> <span class="id">xs2</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">rewrite</span> <span class="id">app_nil_r</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">inversion</span> <span class="id">H</span>; <span class="id">subst</span>. <span class="id">apply</span> <span class="id">IHxs1</span> <span class="kwd">in</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> &lt;- <span class="id">distinct_app_cons</span>. <span class="id">constructor</span>; <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeb_list_fv_incl</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">xs</span> <span class="id">k</span> <span class="id">t</span>, <span class="id">fv</span> (<span class="id">closeb_list</span> <span class="id">k</span> <span class="id">xs</span> <span class="id">t</span>) \<span class="id">subseteq</span> <span class="id">fv</span> <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">xs</span> <span class="kwd">as</span> [|<span class="id">x</span> <span class="id">xs</span>].<br/>
&nbsp;&nbsp;- <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">intros</span>; <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">IHxs</span>. <span class="id">apply</span> <span class="id">fv_closeb</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeb_list_vars_free</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">xs</span> <span class="id">k</span> <span class="id">t</span> <span class="id">x</span>, <span class="id">x</span> \<span class="kwd">in</span> <span class="id">xs</span> -&gt; <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> (<span class="id">closeb_list</span> <span class="id">k</span> <span class="id">xs</span> <span class="id">t</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">xs</span> <span class="kwd">as</span> [|<span class="id">y</span> <span class="id">xs</span>]; <span class="id">intros</span> <span class="id">k</span> <span class="id">t</span> <span class="id">x</span>; [<span class="id">intros</span> [] | <span class="id">intros</span> [-&gt; | <span class="id">Hx</span>]]; <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;- <span class="id">rewrite</span> <span class="id">closeb_list_fv_incl</span>. <span class="id">apply</span> <span class="id">closeb_var_free</span>.<br/>
&nbsp;&nbsp;- <span class="id">apply</span> <span class="id">IHxs</span>. <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<div class="doc">Multicontexts </div>
<br/>
<span class="kwd">Definition</span> <span class="id">multicontext</span> := (<span class="id">freevar</span> * <span class="id">term</span>)%<span class="id">type</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">fill_mctx</span> (<span class="id">K</span> : <span class="id">multicontext</span>) (<span class="id">t</span> : <span class="id">term</span>) := (<span class="id">snd</span> <span class="id">K</span>) [ <span class="id">fst</span> <span class="id">K</span> := <span class="id">t</span> ].<br/>
<span class="kwd">Definition</span> <span class="id">empty_mctx</span> (<span class="id">t</span> : <span class="id">term</span>) : <span class="id">multicontext</span> := (<span class="id">proj1_sig</span> (<span class="id">fresh</span> (<span class="id">fv</span> <span class="id">t</span>)), <span class="id">t</span>).<br/>
<span class="kwd">Definition</span> <span class="id">app_mctx</span> (<span class="id">K1</span> <span class="id">K2</span> : <span class="id">multicontext</span>) : <span class="id">multicontext</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">x</span> := <span class="id">proj1_sig</span> (<span class="id">fresh</span> (<span class="id">fv</span> (<span class="id">snd</span> <span class="id">K1</span>) ++ (<span class="id">fv</span> (<span class="id">snd</span> <span class="id">K2</span>)))) <span class="kwd">in</span> (<span class="id">x</span>, <span class="id">app</span> (<span class="id">fill_mctx</span> <span class="id">K1</span> (<span class="id">fvar</span> <span class="id">x</span>)) (<span class="id">fill_mctx</span> <span class="id">K2</span> (<span class="id">fvar</span> <span class="id">x</span>))).<br/>
<span class="kwd">Definition</span> <span class="id">lam_mctx</span> (<span class="id">K</span> : <span class="id">multicontext</span>) : <span class="id">multicontext</span> := (<span class="id">fst</span> <span class="id">K</span>, <span class="id">lam</span> (<span class="id">snd</span> <span class="id">K</span>)).<br/>
<span class="kwd">Definition</span> <span class="id">constr_mctx</span> (<span class="id">p</span> : <span class="id">nat</span>) (<span class="id">Ks</span> : <span class="id">list</span> <span class="id">multicontext</span>) : <span class="id">multicontext</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">x</span> := <span class="id">proj1_sig</span> (<span class="id">fresh</span> (<span class="id">concat</span> (<span class="id">map</span> (<span class="kwd">fun</span> <span class="id">K</span> =&gt; <span class="id">fv</span> (<span class="id">snd</span> <span class="id">K</span>)) <span class="id">Ks</span>))) <span class="kwd">in</span><br/>
&nbsp;&nbsp;(<span class="id">x</span>, <span class="id">constr</span> <span class="id">p</span> (<span class="id">map</span> (<span class="kwd">fun</span> <span class="id">K</span> =&gt; <span class="id">fill_mctx</span> <span class="id">K</span> (<span class="id">fvar</span> <span class="id">x</span>)) <span class="id">Ks</span>)).<br/>
<span class="kwd">Definition</span> <span class="id">switch_mctx</span> (<span class="id">K</span> : <span class="id">multicontext</span>) (<span class="id">m</span> : <span class="id">list</span> (<span class="id">nat</span> * <span class="id">multicontext</span>)) : <span class="id">multicontext</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">x</span> := <span class="id">proj1_sig</span> (<span class="id">fresh</span> (<span class="id">fv</span> (<span class="id">snd</span> <span class="id">K</span>) ++ <span class="id">concat</span> (<span class="id">map</span> (<span class="kwd">fun</span> '(<span class="id">p</span>, <span class="id">K2</span>) =&gt; <span class="id">fv</span> (<span class="id">snd</span> <span class="id">K2</span>)) <span class="id">m</span>))) <span class="kwd">in</span><br/>
&nbsp;&nbsp;(<span class="id">x</span>, <span class="id">switch</span> (<span class="id">fill_mctx</span> <span class="id">K</span> (<span class="id">fvar</span> <span class="id">x</span>)) (<span class="id">map</span> (<span class="kwd">fun</span> '(<span class="id">p</span>, <span class="id">K2</span>) =&gt; (<span class="id">p</span>, <span class="id">fill_mctx</span> <span class="id">K2</span> (<span class="id">fvar</span> <span class="id">x</span>))) <span class="id">m</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fill_empty</span> : <span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span>, <span class="id">fill_mctx</span> (<span class="id">empty_mctx</span> <span class="id">t1</span>) <span class="id">t2</span> = <span class="id">t1</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t1</span> <span class="id">t2</span>. <span class="id">unfold</span> <span class="id">fill_mctx</span>, <span class="id">empty_mctx</span>. <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span> <span class="id">substf_fv</span>. <span class="id">apply</span> <span class="id">proj2_sig</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">fill_fill</span> : <span class="kwd">forall</span> <span class="id">K</span> <span class="id">x</span> <span class="id">t</span>, <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> (<span class="id">snd</span> <span class="id">K</span>) -&gt; <span class="id">fill_mctx</span> (<span class="id">x</span>, <span class="id">fill_mctx</span> <span class="id">K</span> (<span class="id">fvar</span> <span class="id">x</span>)) <span class="id">t</span> = <span class="id">fill_mctx</span> <span class="id">K</span> <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">K</span> <span class="id">x</span> <span class="id">t</span> <span class="id">Hx</span>. <span class="id">destruct</span> <span class="id">K</span> <span class="kwd">as</span> [<span class="id">y</span> <span class="id">u</span>]; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">unfold</span> <span class="id">fill_mctx</span>; <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">u</span> <span class="kwd">using</span> <span class="id">term_ind2</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span>. <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">simpl</span>. <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">intuition</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">f_equal</span>. <span class="id">apply</span> <span class="id">IHu</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">Hx</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHu1</span>. <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHu2</span>. <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">f_equal</span>. <span class="id">rewrite</span> <span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">u</span> <span class="id">Hu</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">apply</span> <span class="id">H</span>; [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">concat_map_In</span> <span class="kwd">in</span> <span class="id">Hx</span>. <span class="id">intros</span> <span class="id">Hx2</span>; <span class="id">apply</span> <span class="id">Hx</span>; <span class="kwd">exists</span> <span class="id">u</span>; <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">rewrite</span> <span class="id">in_app_iff</span>, <span class="id">concat_map_In</span> <span class="kwd">in</span> <span class="id">Hx</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">apply</span> <span class="id">IHu</span>. <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id">rewrite</span> <span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>. <span class="id">f_equal</span>. <span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); [<span class="id">assumption</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">Hx2</span>; <span class="id">apply</span> <span class="id">Hx</span>; <span class="id">right</span>; <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">fill_app</span> : <span class="kwd">forall</span> <span class="id">K1</span> <span class="id">K2</span> <span class="id">t</span>, <span class="id">fill_mctx</span> (<span class="id">app_mctx</span> <span class="id">K1</span> <span class="id">K2</span>) <span class="id">t</span> = <span class="id">app</span> (<span class="id">fill_mctx</span> <span class="id">K1</span> <span class="id">t</span>) (<span class="id">fill_mctx</span> <span class="id">K2</span> <span class="id">t</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">K1</span> <span class="id">K2</span> <span class="id">t</span>. <span class="id">unfold</span> <span class="id">app_mctx</span>. <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">fresh</span> <span class="kwd">as</span> [<span class="id">x</span> <span class="id">Hx</span>]; <span class="id">simpl</span>; <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id">unfold</span> <span class="id">fill_mctx</span>. <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">f_equal</span>; <span class="id">apply</span> <span class="id">fill_fill</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">fill_lam</span> : <span class="kwd">forall</span> <span class="id">K</span> <span class="id">t</span>, <span class="id">fill_mctx</span> (<span class="id">lam_mctx</span> <span class="id">K</span>) <span class="id">t</span> = <span class="id">lam</span> (<span class="id">fill_mctx</span> <span class="id">K</span> <span class="id">t</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">K</span> <span class="id">t</span>. <span class="id">unfold</span> <span class="id">fill_mctx</span>, <span class="id">lam_mctx</span>. <span class="id">reflexivity</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">fill_constr</span> : <span class="kwd">forall</span> <span class="id">p</span> <span class="id">Ks</span> <span class="id">t</span>, <span class="id">fill_mctx</span> (<span class="id">constr_mctx</span> <span class="id">p</span> <span class="id">Ks</span>) <span class="id">t</span> = <span class="id">constr</span> <span class="id">p</span> (<span class="id">map</span> (<span class="kwd">fun</span> <span class="id">K</span> =&gt; <span class="id">fill_mctx</span> <span class="id">K</span> <span class="id">t</span>) <span class="id">Ks</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">p</span> <span class="id">Ks</span> <span class="id">t</span>. <span class="id">unfold</span> <span class="id">constr_mctx</span>. <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">fresh</span> <span class="kwd">as</span> [<span class="id">x</span> <span class="id">Hx</span>]; <span class="id">simpl</span>; <span class="id">rewrite</span> <span class="id">concat_map_In</span> <span class="kwd">in</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id">unfold</span> <span class="id">fill_mctx</span>. <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">map_map</span>.<br/>
&nbsp;&nbsp;<span class="id">f_equal</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>. <span class="id">intros</span> <span class="id">K</span> <span class="id">HK</span>; <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span> <span class="id">fill_fill</span>. <span class="id">intros</span> <span class="id">Hx2</span>; <span class="id">apply</span> <span class="id">Hx</span>; <span class="kwd">exists</span> <span class="id">K</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">fill_switch</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">K</span> <span class="id">m</span> <span class="id">t</span>, <span class="id">fill_mctx</span> (<span class="id">switch_mctx</span> <span class="id">K</span> <span class="id">m</span>) <span class="id">t</span> = <span class="id">switch</span> (<span class="id">fill_mctx</span> <span class="id">K</span> <span class="id">t</span>) (<span class="id">map</span> (<span class="kwd">fun</span> '(<span class="id">p</span>, <span class="id">K2</span>) =&gt; (<span class="id">p</span>, <span class="id">fill_mctx</span> <span class="id">K2</span> <span class="id">t</span>)) <span class="id">m</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">K</span> <span class="id">m</span> <span class="id">t</span>. <span class="id">unfold</span> <span class="id">switch_mctx</span>. <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">fresh</span> <span class="kwd">as</span> [<span class="id">x</span> <span class="id">Hx</span>]; <span class="id">simpl</span>; <span class="id">rewrite</span> <span class="id">in_app_iff</span>, <span class="id">concat_map_In</span> <span class="kwd">in</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id">unfold</span> <span class="id">fill_mctx</span>. <span class="id">simpl</span>. <span class="id">rewrite</span> <span class="id">map_map</span>.<br/>
&nbsp;&nbsp;<span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;- <span class="id">apply</span> <span class="id">fill_fill</span>. <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">apply</span> <span class="id">map_ext_in</span>. <span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>; <span class="id">f_equal</span>. <span class="id">apply</span> <span class="id">fill_fill</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span> <span class="id">Hx2</span>; <span class="id">apply</span> <span class="id">Hx</span>; <span class="id">right</span>; <span class="kwd">exists</span> (<span class="id">p</span>, <span class="id">t2</span>); <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Definition</span> <span class="id">lc_mctx</span> (<span class="id">K</span> : <span class="id">multicontext</span>) := <span class="id">lc</span> (<span class="id">snd</span> <span class="id">K</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">hole</span> : <span class="id">multicontext</span> := (<span class="kwd">let</span> <span class="id">x</span> := <span class="id">proj1_sig</span> (<span class="id">fresh</span> <span class="id">nil</span>) <span class="kwd">in</span> (<span class="id">x</span>, <span class="id">fvar</span> <span class="id">x</span>)).<br/>
<span class="kwd">Lemma</span> <span class="id">fill_hole</span> : <span class="kwd">forall</span> <span class="id">t</span>, <span class="id">fill_mctx</span> <span class="id">hole</span> <span class="id">t</span> = <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span>. <span class="id">unfold</span> <span class="id">hole</span>, <span class="id">fill_mctx</span>. <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; <span class="id">congruence</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Definition</span> <span class="id">closeb_mctx</span> <span class="id">k</span> <span class="id">x</span> (<span class="id">K</span> : <span class="id">multicontext</span>) : <span class="id">multicontext</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">y</span> := <span class="id">proj1_sig</span> (<span class="id">fresh</span> (<span class="id">x</span> :: <span class="id">fv</span> (<span class="id">snd</span> <span class="id">K</span>))) <span class="kwd">in</span> (<span class="id">y</span>, <span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> (<span class="id">fill_mctx</span> <span class="id">K</span> (<span class="id">fvar</span> <span class="id">y</span>))).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeb_fill</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">k</span> <span class="id">x</span> <span class="id">K</span> <span class="id">t</span>, <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">t</span> -&gt; <span class="id">fill_mctx</span> (<span class="id">closeb_mctx</span> <span class="id">k</span> <span class="id">x</span> <span class="id">K</span>) <span class="id">t</span> = <span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> (<span class="id">fill_mctx</span> <span class="id">K</span> <span class="id">t</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">k</span> <span class="id">x</span> [<span class="id">y</span> <span class="id">K</span>] <span class="id">t</span> <span class="id">Hx</span>. <span class="id">unfold</span> <span class="id">closeb_mctx</span>, <span class="id">fill_mctx</span>. <span class="id">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">fresh</span> <span class="kwd">as</span> [<span class="id">z</span> <span class="id">Hz</span>]; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">closeb_substf_free</span> <span class="kwd">by</span> <span class="id">tauto</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span> <span class="id">fill_fill</span> <span class="kwd">with</span> (<span class="id">K</span> := (<span class="id">y</span>, <span class="id">K</span>)). <span class="id">simpl</span>. <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">body_app</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span>, <span class="id">body</span> <span class="id">t1</span> -&gt; <span class="id">body</span> <span class="id">t2</span> -&gt; <span class="id">body</span> (<span class="id">app</span> <span class="id">t1</span> <span class="id">t2</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t1</span> <span class="id">t2</span> [<span class="id">L1</span> <span class="id">H1</span>] [<span class="id">L2</span> <span class="id">H2</span>]. <span class="kwd">exists</span> (<span class="id">L1</span> ++ <span class="id">L2</span>).<br/>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">x</span> <span class="id">Hx</span>; <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">Hx</span>; <span class="id">simpl</span>; <span class="id">constructor</span>; [<span class="id">apply</span> <span class="id">H1</span> | <span class="id">apply</span> <span class="id">H2</span>]; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">lc_body_one</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">x</span>, <span class="id">lc</span> (<span class="id">t</span> ^ <span class="id">x</span>) -&gt; <span class="id">body</span> <span class="id">t</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">x</span> <span class="id">H</span>. <span class="kwd">exists</span> (<span class="id">fv</span> <span class="id">t</span>). <span class="id">intros</span> <span class="id">y</span> <span class="id">Hy</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substb_is_substf</span> <span class="kwd">with</span> (<span class="id">x</span> := <span class="id">y</span>) <span class="kwd">in</span> <span class="id">H</span> <span class="kwd">by</span> <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span> <span class="id">substf_lc2</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">closeb_body</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">x</span>, <span class="id">lc</span> <span class="id">t</span> -&gt; <span class="id">body</span> (<span class="id">closeb</span> 0 <span class="id">x</span> <span class="id">t</span>).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">t</span> <span class="id">x</span> <span class="id">H</span>. <span class="id">apply</span> <span class="id">lc_body_one</span> <span class="kwd">with</span> (<span class="id">x</span> := <span class="id">x</span>). <span class="id">rewrite</span> <span class="id">open_close_var</span>; <span class="id">assumption</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">open_close2</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span> <span class="id">k</span> <span class="id">x</span> <span class="id">u</span>, <span class="id">lc</span> <span class="id">u</span> -&gt; (<span class="id">closeb</span> <span class="id">k</span> <span class="id">x</span> <span class="id">t</span>) [ <span class="id">k</span> &lt;- <span class="id">u</span> ] = (<span class="id">t</span> [ <span class="id">x</span> := <span class="id">u</span> ]) [ <span class="id">k</span> &lt;- <span class="id">u</span> ].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">induction</span> <span class="id">t</span> <span class="kwd">using</span> <span class="id">term_ind2</span>; <span class="id">intros</span> <span class="id">k</span> <span class="id">x</span> <span class="id">u</span> <span class="id">Hlc</span>; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;- <span class="id">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id">destruct</span> <span class="id">freevar_eq_dec</span>; [|<span class="id">reflexivity</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl</span>. <span class="id">destruct</span> <span class="id">Nat.eq_dec</span>; [|<span class="id">tauto</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substb_lc_id</span>; [<span class="id">reflexivity</span>|<span class="id">assumption</span>].<br/>
&nbsp;&nbsp;- <span class="id">f_equal</span>. <span class="id">apply</span> <span class="id">IHt</span>. <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">f_equal</span>; <span class="id">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id">f_equal</span>. <span class="id">rewrite</span> !<span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>. <span class="id">intros</span> <span class="id">t</span> <span class="id">Ht</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">apply</span> <span class="id">H</span>; <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id">f_equal</span>; [<span class="id">apply</span> <span class="id">IHt</span>; <span class="id">tauto</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> !<span class="id">map_map</span>. <span class="id">apply</span> <span class="id">map_ext_in</span>. <span class="id">intros</span> [<span class="id">p</span> <span class="id">t2</span>] <span class="id">Hpt2</span>. <span class="id">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">Forall_forall</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">apply</span> (<span class="id">H</span> (<span class="id">p</span>, <span class="id">t2</span>)); <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Definition</span> <span class="id">substb_mctx</span> (<span class="id">K1</span> <span class="id">K2</span> : <span class="id">multicontext</span>) <span class="id">k</span> : <span class="id">multicontext</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">z</span> := <span class="id">proj1_sig</span> (<span class="id">fresh</span> (<span class="id">fv</span> (<span class="id">snd</span> <span class="id">K1</span>) ++ <span class="id">fv</span> (<span class="id">snd</span> <span class="id">K2</span>))) <span class="kwd">in</span><br/>
&nbsp;&nbsp;(<span class="id">z</span>, (<span class="id">fill_mctx</span> <span class="id">K1</span> (<span class="id">fvar</span> <span class="id">z</span>)) [ <span class="id">k</span> &lt;- <span class="id">fill_mctx</span> <span class="id">K2</span> (<span class="id">fvar</span> <span class="id">z</span>)]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fill_substb</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">K1</span> <span class="id">K2</span> <span class="id">k</span> <span class="id">t</span>, <span class="id">lc</span> <span class="id">t</span> -&gt; <span class="id">fill_mctx</span> (<span class="id">substb_mctx</span> <span class="id">K1</span> <span class="id">K2</span> <span class="id">k</span>) <span class="id">t</span> = (<span class="id">fill_mctx</span> <span class="id">K1</span> <span class="id">t</span>) [ <span class="id">k</span> &lt;- <span class="id">fill_mctx</span> <span class="id">K2</span> <span class="id">t</span> ].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> [<span class="id">x</span> <span class="id">K1</span>] [<span class="id">y</span> <span class="id">K2</span>] <span class="id">k</span> <span class="id">t</span> <span class="id">Hlc</span>. <span class="id">unfold</span> <span class="id">substb_mctx</span>, <span class="id">fill_mctx</span> <span class="kwd">in</span> *; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">fresh</span> <span class="kwd">as</span> [<span class="id">z</span> <span class="id">Hz</span>]; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substb_substf</span> <span class="kwd">by</span> <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id">f_equal</span>; <span class="id">apply</span> <span class="id">fill_fill</span> <span class="kwd">with</span> (<span class="id">K</span> := (<span class="id">_</span>, <span class="id">_</span>)); <span class="id">simpl</span>; <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">Hz</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Definition</span> <span class="id">substf_mctx</span> (<span class="id">K1</span> <span class="id">K2</span> : <span class="id">multicontext</span>) <span class="id">x</span> : <span class="id">multicontext</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">z</span> := <span class="id">proj1_sig</span> (<span class="id">fresh</span> (<span class="id">x</span> :: <span class="id">fv</span> (<span class="id">snd</span> <span class="id">K1</span>) ++ <span class="id">fv</span> (<span class="id">snd</span> <span class="id">K2</span>))) <span class="kwd">in</span><br/>
&nbsp;&nbsp;(<span class="id">z</span>, (<span class="id">fill_mctx</span> <span class="id">K1</span> (<span class="id">fvar</span> <span class="id">z</span>)) [ <span class="id">x</span> := <span class="id">fill_mctx</span> <span class="id">K2</span> (<span class="id">fvar</span> <span class="id">z</span>)]).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fill_substf</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">K1</span> <span class="id">K2</span> <span class="id">x</span> <span class="id">t</span>, <span class="id">x</span> \<span class="id">notin</span> <span class="id">fv</span> <span class="id">t</span> -&gt; <span class="id">fill_mctx</span> (<span class="id">substf_mctx</span> <span class="id">K1</span> <span class="id">K2</span> <span class="id">x</span>) <span class="id">t</span> = (<span class="id">fill_mctx</span> <span class="id">K1</span> <span class="id">t</span>) [ <span class="id">x</span> := <span class="id">fill_mctx</span> <span class="id">K2</span> <span class="id">t</span> ].<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> [<span class="id">x</span> <span class="id">K1</span>] [<span class="id">y</span> <span class="id">K2</span>] <span class="id">w</span> <span class="id">t</span> <span class="id">Hw</span>. <span class="id">unfold</span> <span class="id">substf_mctx</span>, <span class="id">fill_mctx</span> <span class="kwd">in</span> *; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">fresh</span> <span class="kwd">as</span> [<span class="id">z</span> <span class="id">Hz</span>]; <span class="id">simpl</span> <span class="kwd">in</span> *; <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">Hz</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> <span class="id">substf_substf</span> <span class="kwd">by</span> <span class="id">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id">f_equal</span>; <span class="id">apply</span> <span class="id">fill_fill</span> <span class="kwd">with</span> (<span class="id">K</span> := (<span class="id">_</span>, <span class="id">_</span>)); <span class="id">simpl</span>; <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<span class="kwd">Lemma</span> <span class="id">fill_substf2</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">K1</span> <span class="id">t2</span> <span class="id">x</span> <span class="id">t</span>, (<span class="id">fill_mctx</span> <span class="id">K1</span> <span class="id">t</span>) [ <span class="id">x</span> := <span class="id">t2</span> ] = <span class="id">fill_mctx</span> (<span class="id">substf_mctx</span> <span class="id">K1</span> (<span class="id">empty_mctx</span> <span class="id">t2</span>) <span class="id">x</span>) (<span class="id">t</span> [ <span class="id">x</span> := <span class="id">t2</span> ]).<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> [<span class="id">x</span> <span class="id">K</span>] <span class="id">t2</span> <span class="id">w</span> <span class="id">t</span>.<br/>
&nbsp;&nbsp;<span class="id">unfold</span> <span class="id">substf_mctx</span> <span class="kwd">in</span> *; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">rewrite</span> <span class="id">fill_empty</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">unfold</span> <span class="id">fill_mctx</span> <span class="kwd">in</span> *; <span class="id">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> <span class="id">fresh</span> <span class="kwd">as</span> [<span class="id">z</span> <span class="id">Hz</span>]; <span class="id">simpl</span> <span class="kwd">in</span> *. <span class="id">rewrite</span> <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">Hz</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> &lt;- <span class="id">substf_substf</span> <span class="kwd">with</span> (<span class="id">x1</span> := <span class="id">z</span>) <span class="kwd">by</span> <span class="id">intuition</span> <span class="id">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">f_equal</span>. <span class="id">symmetry</span>; <span class="id">apply</span> <span class="id">fill_fill</span> <span class="kwd">with</span> (<span class="id">K</span> := (<span class="id">_</span>, <span class="id">_</span>)). <span class="id">simpl</span>. <span class="id">tauto</span>.<br/>
Qed.</details>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">fill_open</span> :<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">K</span> <span class="id">t1</span> <span class="id">t2</span>, <span class="id">lc</span> <span class="id">t1</span> -&gt; (<span class="id">fill_mctx</span> <span class="id">K</span> <span class="id">t1</span>) ^^ <span class="id">t2</span> = <span class="id">fill_mctx</span> (<span class="id">substb_mctx</span> <span class="id">K</span> (<span class="id">empty_mctx</span> <span class="id">t2</span>) 0) <span class="id">t1</span>.<br/>
<details><summary>Proof.</summary>
&nbsp;&nbsp;<span class="id">intros</span> <span class="id">K</span> <span class="id">t1</span> <span class="id">t2</span> <span class="id">H</span>. <span class="id">rewrite</span> <span class="id">fill_substb</span> <span class="kwd">by</span> <span class="id">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id">f_equal</span>. <span class="id">rewrite</span> <span class="id">fill_empty</span>. <span class="id">reflexivity</span>.<br/>
Qed.</details>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/xavierleroy/coq2html/">coq2html</a></div>
</body>
</html>
